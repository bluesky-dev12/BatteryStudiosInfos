#include "stdafx.h"
/*
# ======================================================================================== #
# > ArcticCombat SDK
# > Generated By HJSdkGen v1.06b
# ---------------------------------------------------------------------------------------- #
# > Package : Core
# >    File : Code.cpp
# ======================================================================================== #
*/

void UObject::NotifyDestroyed ( class AActor* A )
{
	static UFunction* pNotifyDestroyed = 0;
	UObject_execNotifyDestroyed_Parms parms;

	if ( !pNotifyDestroyed )
		pNotifyDestroyed = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.NotifyDestroyed" );

	parms.A = A;
	this->ProcessEvent ( pNotifyDestroyed, &parms, NULL );

}

void UObject::ZeroVector ( struct FVector* V )
{
	static UFunction* pZeroVector = 0;
	UObject_execZeroVector_Parms parms;

	if ( !pZeroVector )
		pZeroVector = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.ZeroVector" );

	parms.V = *V;
	this->ProcessEvent ( pZeroVector, &parms, NULL );

	*V = parms.V;
}

bool UObject::IsZeroVector ( struct FVector* V )
{
	static UFunction* pIsZeroVector = 0;
	UObject_execIsZeroVector_Parms parms;

	if ( !pIsZeroVector )
		pIsZeroVector = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.IsZeroVector" );

	parms.V = *V;
	this->ProcessEvent ( pIsZeroVector, &parms, NULL );

	*V = parms.V;
	return parms.ReturnValue;
}

float UObject::Pow ( float A, int B )
{
	static UFunction* pPow = 0;
	UObject_execPow_Parms parms;

	if ( !pPow )
		pPow = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Pow" );

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pPow, &parms, NULL );

	return parms.ReturnValue;
}

bool UObject::StrStartsWith ( struct FString str, struct FString startStr )
{
	static UFunction* pStrStartsWith = 0;
	UObject_execStrStartsWith_Parms parms;

	if ( !pStrStartsWith )
		pStrStartsWith = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.StrStartsWith" );

	parms.str = str;
	parms.startStr = startStr;
	this->ProcessEvent ( pStrStartsWith, &parms, NULL );

	return parms.ReturnValue;
}

struct FString UObject::PadRight ( struct FString str, int totalDigits, struct FString paddingChar )
{
	static UFunction* pPadRight = 0;
	UObject_execPadRight_Parms parms;

	if ( !pPadRight )
		pPadRight = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.PadRight" );

	parms.str = str;
	parms.totalDigits = totalDigits;
	parms.paddingChar = paddingChar;
	this->ProcessEvent ( pPadRight, &parms, NULL );

	return parms.ReturnValue;
}

struct FString UObject::PadLeft ( struct FString str, int totalDigits, struct FString paddingChar )
{
	static UFunction* pPadLeft = 0;
	UObject_execPadLeft_Parms parms;

	if ( !pPadLeft )
		pPadLeft = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.PadLeft" );

	parms.str = str;
	parms.totalDigits = totalDigits;
	parms.paddingChar = paddingChar;
	this->ProcessEvent ( pPadLeft, &parms, NULL );

	return parms.ReturnValue;
}

struct FString UObject::PadString ( struct FString str, int totalDigits, struct FString paddingChar )
{
	static UFunction* pPadString = 0;
	UObject_execPadString_Parms parms;

	if ( !pPadString )
		pPadString = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.PadString" );

	parms.str = str;
	parms.totalDigits = totalDigits;
	parms.paddingChar = paddingChar;
	this->ProcessEvent ( pPadString, &parms, NULL );

	return parms.ReturnValue;
}

void UObject::slog ( struct FString S )
{
	static UFunction* pslog = 0;
	UObject_execslog_Parms parms;

	if ( !pslog )
		pslog = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.slog" );

	parms.S = S;
	this->ProcessEvent ( pslog, &parms, NULL );

}

struct FVector UObject::MakeVector ( float X, float Y, float Z )
{
	static UFunction* pMakeVector = 0;
	UObject_execMakeVector_Parms parms;

	if ( !pMakeVector )
		pMakeVector = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.MakeVector" );

	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;
	this->ProcessEvent ( pMakeVector, &parms, NULL );

	return parms.ReturnValue;
}

void UObject::EatStr ( int Num, struct FString* Dest, struct FString* Source )
{
	static UFunction* pEatStr = 0;
	UObject_execEatStr_Parms parms;

	if ( !pEatStr )
		pEatStr = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.EatStr" );

	parms.Num = Num;
	this->ProcessEvent ( pEatStr, &parms, NULL );

	*Dest = parms.Dest;
	*Source = parms.Source;
}

void UObject::ReplaceText ( struct FString Replace, struct FString With, struct FString* Text )
{
	static UFunction* pReplaceText = 0;
	UObject_execReplaceText_Parms parms;

	if ( !pReplaceText )
		pReplaceText = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.ReplaceText" );

	parms.Replace = Replace;
	parms.With = With;
	this->ProcessEvent ( pReplaceText, &parms, NULL );

	*Text = parms.Text;
}

struct FString UObject::GetItemName ( struct FString FullName )
{
	static UFunction* pGetItemName = 0;
	UObject_execGetItemName_Parms parms;

	if ( !pGetItemName )
		pGetItemName = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.GetItemName" );

	parms.FullName = FullName;
	this->ProcessEvent ( pGetItemName, &parms, NULL );

	return parms.ReturnValue;
}

void UObject::GetDatefromString ( struct FString _char, bool bFull, struct FString* in )
{
	static UFunction* pGetDatefromString = 0;
	UObject_execGetDatefromString_Parms parms;

	if ( !pGetDatefromString )
		pGetDatefromString = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.GetDatefromString" );

	parms._char = _char;
	parms.bFull = bFull;
	this->ProcessEvent ( pGetDatefromString, &parms, NULL );

	*in = parms.in;
}

void UObject::GetReferencers ( class UObject* Target, class TArray< class UObject* >* Referencers )
{
	static UFunction* pGetReferencers = 0;
	UObject_execGetReferencers_Parms parms;

	if ( !pGetReferencers )
		pGetReferencers = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.GetReferencers" );

	parms.Target = Target;
	this->ProcessEvent ( pGetReferencers, &parms, NULL );

	*Referencers = parms.Referencers;
}

void UObject::AllObjects ( class UClass* baseClass, class UObject** obj )
{
	static UFunction* pAllObjects = 0;
	UObject_execAllObjects_Parms parms;

	if ( !pAllObjects )
		pAllObjects = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.AllObjects" );

	WORD iNative = pAllObjects->iNative;
	pAllObjects->FunctionFlags &= ~FUNC_Native;
	pAllObjects->iNative = 0;

	parms.baseClass = baseClass;
	this->ProcessEvent ( pAllObjects, &parms, NULL );

	pAllObjects->iNative = iNative;
	pAllObjects->FunctionFlags |= FUNC_Native;
	*obj = parms.obj;
}

void UObject::eventCreated (  )
{
	static UFunction* pCreated = 0;
	UObject_eventCreated_Parms parms;

	if ( !pCreated )
		pCreated = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Created" );

	this->ProcessEvent ( pCreated, &parms, NULL );

}

void UObject::eventEndState (  )
{
	static UFunction* pEndState = 0;
	UObject_eventEndState_Parms parms;

	if ( !pEndState )
		pEndState = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.EndState" );

	this->ProcessEvent ( pEndState, &parms, NULL );

}

void UObject::eventBeginState (  )
{
	static UFunction* pBeginState = 0;
	UObject_eventBeginState_Parms parms;

	if ( !pBeginState )
		pBeginState = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.BeginState" );

	this->ProcessEvent ( pBeginState, &parms, NULL );

}

struct FString UObject::GetErrMsg ( int ErrCode )
{
	static UFunction* pGetErrMsg = 0;
	UObject_execGetErrMsg_Parms parms;

	if ( !pGetErrMsg )
		pGetErrMsg = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.GetErrMsg" );

	parms.ErrCode = ErrCode;
	this->ProcessEvent ( pGetErrMsg, &parms, NULL );

	return parms.ReturnValue;
}

int UObject::GetLastErrCode (  )
{
	static UFunction* pGetLastErrCode = 0;
	UObject_execGetLastErrCode_Parms parms;

	if ( !pGetLastErrCode )
		pGetLastErrCode = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.GetLastErrCode" );

	this->ProcessEvent ( pGetLastErrCode, &parms, NULL );

	return parms.ReturnValue;
}

bool UObject::PlatformIs64Bit (  )
{
	static UFunction* pPlatformIs64Bit = 0;
	UObject_execPlatformIs64Bit_Parms parms;

	if ( !pPlatformIs64Bit )
		pPlatformIs64Bit = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.PlatformIs64Bit" );

	this->ProcessEvent ( pPlatformIs64Bit, &parms, NULL );

	return parms.ReturnValue;
}

bool UObject::PlatformIsWindows (  )
{
	static UFunction* pPlatformIsWindows = 0;
	UObject_execPlatformIsWindows_Parms parms;

	if ( !pPlatformIsWindows )
		pPlatformIsWindows = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.PlatformIsWindows" );

	this->ProcessEvent ( pPlatformIsWindows, &parms, NULL );

	return parms.ReturnValue;
}

bool UObject::PlatformIsUnix (  )
{
	static UFunction* pPlatformIsUnix = 0;
	UObject_execPlatformIsUnix_Parms parms;

	if ( !pPlatformIsUnix )
		pPlatformIsUnix = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.PlatformIsUnix" );

	this->ProcessEvent ( pPlatformIsUnix, &parms, NULL );

	return parms.ReturnValue;
}

bool UObject::PlatformIsMacOS (  )
{
	static UFunction* pPlatformIsMacOS = 0;
	UObject_execPlatformIsMacOS_Parms parms;

	if ( !pPlatformIsMacOS )
		pPlatformIsMacOS = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.PlatformIsMacOS" );

	this->ProcessEvent ( pPlatformIsMacOS, &parms, NULL );

	return parms.ReturnValue;
}

bool UObject::IsSoaking (  )
{
	static UFunction* pIsSoaking = 0;
	UObject_execIsSoaking_Parms parms;

	if ( !pIsSoaking )
		pIsSoaking = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.IsSoaking" );

	this->ProcessEvent ( pIsSoaking, &parms, NULL );

	return parms.ReturnValue;
}

bool UObject::IsOnConsole (  )
{
	static UFunction* pIsOnConsole = 0;
	UObject_execIsOnConsole_Parms parms;

	if ( !pIsOnConsole )
		pIsOnConsole = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.IsOnConsole" );

	this->ProcessEvent ( pIsOnConsole, &parms, NULL );

	return parms.ReturnValue;
}

void UObject::StopWatch ( bool bStop )
{
	static UFunction* pStopWatch = 0;
	UObject_execStopWatch_Parms parms;

	if ( !pStopWatch )
		pStopWatch = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.StopWatch" );

	WORD iNative = pStopWatch->iNative;
	pStopWatch->FunctionFlags &= ~FUNC_Native;
	pStopWatch->iNative = 0;

	parms.bStop = bStop;
	this->ProcessEvent ( pStopWatch, &parms, NULL );

	pStopWatch->iNative = iNative;
	pStopWatch->FunctionFlags |= FUNC_Native;
}

float UObject::RandRange ( float Min, float Max )
{
	static UFunction* pRandRange = 0;
	UObject_execRandRange_Parms parms;

	if ( !pRandRange )
		pRandRange = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.RandRange" );

	parms.Min = Min;
	parms.Max = Max;
	this->ProcessEvent ( pRandRange, &parms, NULL );

	return parms.ReturnValue;
}

class TArray< struct FString > UObject::GetPerObjectNames ( struct FString ININame, struct FString ObjectClass, int MaxResults )
{
	static UFunction* pGetPerObjectNames = 0;
	UObject_execGetPerObjectNames_Parms parms;

	if ( !pGetPerObjectNames )
		pGetPerObjectNames = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.GetPerObjectNames" );

	parms.ININame = ININame;
	parms.ObjectClass = ObjectClass;
	parms.MaxResults = MaxResults;
	this->ProcessEvent ( pGetPerObjectNames, &parms, NULL );

	return parms.ReturnValue;
}

void UObject::StaticClearConfig ( struct FString PropName )
{
	static UFunction* pStaticClearConfig = 0;
	UObject_execStaticClearConfig_Parms parms;

	if ( !pStaticClearConfig )
		pStaticClearConfig = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.StaticClearConfig" );

	parms.PropName = PropName;
	this->ProcessEvent ( pStaticClearConfig, &parms, NULL );

}

void UObject::ResetConfig ( struct FString PropName )
{
	static UFunction* pResetConfig = 0;
	UObject_execResetConfig_Parms parms;

	if ( !pResetConfig )
		pResetConfig = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.ResetConfig" );

	parms.PropName = PropName;
	this->ProcessEvent ( pResetConfig, &parms, NULL );

}

void UObject::StaticSaveConfig (  )
{
	static UFunction* pStaticSaveConfig = 0;
	UObject_execStaticSaveConfig_Parms parms;

	if ( !pStaticSaveConfig )
		pStaticSaveConfig = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.StaticSaveConfig" );

	this->ProcessEvent ( pStaticSaveConfig, &parms, NULL );

}

void UObject::ClearConfig ( struct FString PropName )
{
	static UFunction* pClearConfig = 0;
	UObject_execClearConfig_Parms parms;

	if ( !pClearConfig )
		pClearConfig = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.ClearConfig" );

	WORD iNative = pClearConfig->iNative;
	pClearConfig->FunctionFlags &= ~FUNC_Native;
	pClearConfig->iNative = 0;

	parms.PropName = PropName;
	this->ProcessEvent ( pClearConfig, &parms, NULL );

	pClearConfig->iNative = iNative;
	pClearConfig->FunctionFlags |= FUNC_Native;
}

void UObject::SaveConfig (  )
{
	static UFunction* pSaveConfig = 0;
	UObject_execSaveConfig_Parms parms;

	if ( !pSaveConfig )
		pSaveConfig = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.SaveConfig" );

	WORD iNative = pSaveConfig->iNative;
	pSaveConfig->FunctionFlags &= ~FUNC_Native;
	pSaveConfig->iNative = 0;

	this->ProcessEvent ( pSaveConfig, &parms, NULL );

	pSaveConfig->iNative = iNative;
	pSaveConfig->FunctionFlags |= FUNC_Native;
}

class UObject* UObject::FindObject ( struct FString ObjectName, class UClass* ObjectClass )
{
	static UFunction* pFindObject = 0;
	UObject_execFindObject_Parms parms;

	if ( !pFindObject )
		pFindObject = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.FindObject" );

	parms.ObjectName = ObjectName;
	parms.ObjectClass = ObjectClass;
	this->ProcessEvent ( pFindObject, &parms, NULL );

	return parms.ReturnValue;
}

class UObject* UObject::DynamicLoadObject ( struct FString ObjectName, class UClass* ObjectClass, bool MayFail )
{
	static UFunction* pDynamicLoadObject = 0;
	UObject_execDynamicLoadObject_Parms parms;

	if ( !pDynamicLoadObject )
		pDynamicLoadObject = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.DynamicLoadObject" );

	parms.ObjectName = ObjectName;
	parms.ObjectClass = ObjectClass;
	parms.MayFail = MayFail;
	this->ProcessEvent ( pDynamicLoadObject, &parms, NULL );

	return parms.ReturnValue;
}

struct FName UObject::GetEnum ( class UObject* E, int i )
{
	static UFunction* pGetEnum = 0;
	UObject_execGetEnum_Parms parms;

	if ( !pGetEnum )
		pGetEnum = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.GetEnum" );

	parms.E = E;
	parms.i = i;
	this->ProcessEvent ( pGetEnum, &parms, NULL );

	return parms.ReturnValue;
}

bool UObject::SetPropertyText ( struct FString PropName, struct FString PropValue )
{
	static UFunction* pSetPropertyText = 0;
	UObject_execSetPropertyText_Parms parms;

	if ( !pSetPropertyText )
		pSetPropertyText = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.SetPropertyText" );

	parms.PropName = PropName;
	parms.PropValue = PropValue;
	this->ProcessEvent ( pSetPropertyText, &parms, NULL );

	return parms.ReturnValue;
}

struct FString UObject::GetPropertyText ( struct FString PropName )
{
	static UFunction* pGetPropertyText = 0;
	UObject_execGetPropertyText_Parms parms;

	if ( !pGetPropertyText )
		pGetPropertyText = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.GetPropertyText" );

	parms.PropName = PropName;
	this->ProcessEvent ( pGetPropertyText, &parms, NULL );

	return parms.ReturnValue;
}

void UObject::Disable ( struct FName ProbeFunc )
{
	static UFunction* pDisable = 0;
	UObject_execDisable_Parms parms;

	if ( !pDisable )
		pDisable = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Disable" );

	WORD iNative = pDisable->iNative;
	pDisable->FunctionFlags &= ~FUNC_Native;
	pDisable->iNative = 0;

	parms.ProbeFunc = ProbeFunc;
	this->ProcessEvent ( pDisable, &parms, NULL );

	pDisable->iNative = iNative;
	pDisable->FunctionFlags |= FUNC_Native;
}

void UObject::Enable ( struct FName ProbeFunc )
{
	static UFunction* pEnable = 0;
	UObject_execEnable_Parms parms;

	if ( !pEnable )
		pEnable = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Enable" );

	WORD iNative = pEnable->iNative;
	pEnable->FunctionFlags &= ~FUNC_Native;
	pEnable->iNative = 0;

	parms.ProbeFunc = ProbeFunc;
	this->ProcessEvent ( pEnable, &parms, NULL );

	pEnable->iNative = iNative;
	pEnable->FunctionFlags |= FUNC_Native;
}

bool UObject::IsA ( struct FName ClassName )
{
	static UFunction* pIsA = 0;
	UObject_execIsA_Parms parms;

	if ( !pIsA )
		pIsA = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.IsA" );

	WORD iNative = pIsA->iNative;
	pIsA->FunctionFlags &= ~FUNC_Native;
	pIsA->iNative = 0;

	parms.ClassName = ClassName;
	this->ProcessEvent ( pIsA, &parms, NULL );

	pIsA->iNative = iNative;
	pIsA->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::ClassIsChildOf ( class UClass* TestClass, class UClass* ParentClass )
{
	static UFunction* pClassIsChildOf = 0;
	UObject_execClassIsChildOf_Parms parms;

	if ( !pClassIsChildOf )
		pClassIsChildOf = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.ClassIsChildOf" );

	WORD iNative = pClassIsChildOf->iNative;
	pClassIsChildOf->FunctionFlags &= ~FUNC_Native;
	pClassIsChildOf->iNative = 0;

	parms.TestClass = TestClass;
	parms.ParentClass = ParentClass;
	this->ProcessEvent ( pClassIsChildOf, &parms, NULL );

	pClassIsChildOf->iNative = iNative;
	pClassIsChildOf->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FName UObject::GetStateName (  )
{
	static UFunction* pGetStateName = 0;
	UObject_execGetStateName_Parms parms;

	if ( !pGetStateName )
		pGetStateName = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.GetStateName" );

	WORD iNative = pGetStateName->iNative;
	pGetStateName->FunctionFlags &= ~FUNC_Native;
	pGetStateName->iNative = 0;

	this->ProcessEvent ( pGetStateName, &parms, NULL );

	pGetStateName->iNative = iNative;
	pGetStateName->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::IsInState ( struct FName TestState )
{
	static UFunction* pIsInState = 0;
	UObject_execIsInState_Parms parms;

	if ( !pIsInState )
		pIsInState = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.IsInState" );

	WORD iNative = pIsInState->iNative;
	pIsInState->FunctionFlags &= ~FUNC_Native;
	pIsInState->iNative = 0;

	parms.TestState = TestState;
	this->ProcessEvent ( pIsInState, &parms, NULL );

	pIsInState->iNative = iNative;
	pIsInState->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

void UObject::GotoState ( struct FName NewState, struct FName Label )
{
	static UFunction* pGotoState = 0;
	UObject_execGotoState_Parms parms;

	if ( !pGotoState )
		pGotoState = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.GotoState" );

	WORD iNative = pGotoState->iNative;
	pGotoState->FunctionFlags &= ~FUNC_Native;
	pGotoState->iNative = 0;

	parms.NewState = NewState;
	parms.Label = Label;
	this->ProcessEvent ( pGotoState, &parms, NULL );

	pGotoState->iNative = iNative;
	pGotoState->FunctionFlags |= FUNC_Native;
}

void UObject::ResetCombatLog (  )
{
	static UFunction* pResetCombatLog = 0;
	UObject_execResetCombatLog_Parms parms;

	if ( !pResetCombatLog )
		pResetCombatLog = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.ResetCombatLog" );

	this->ProcessEvent ( pResetCombatLog, &parms, NULL );

}

void UObject::CombatLog ( struct FString S, struct FName Tag )
{
	static UFunction* pCombatLog = 0;
	UObject_execCombatLog_Parms parms;

	if ( !pCombatLog )
		pCombatLog = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.CombatLog" );

	parms.S = S;
	parms.Tag = Tag;
	this->ProcessEvent ( pCombatLog, &parms, NULL );

}

void UObject::CrashLog ( struct FString S, struct FName Tag )
{
	static UFunction* pCrashLog = 0;
	UObject_execCrashLog_Parms parms;

	if ( !pCrashLog )
		pCrashLog = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.CrashLog" );

	WORD iNative = pCrashLog->iNative;
	pCrashLog->FunctionFlags &= ~FUNC_Native;
	pCrashLog->iNative = 0;

	parms.S = S;
	parms.Tag = Tag;
	this->ProcessEvent ( pCrashLog, &parms, NULL );

	pCrashLog->iNative = iNative;
	pCrashLog->FunctionFlags |= FUNC_Native;
}

struct FString UObject::Localize ( struct FString SectionName, struct FString KeyName, struct FString PackageName )
{
	static UFunction* pLocalize = 0;
	UObject_execLocalize_Parms parms;

	if ( !pLocalize )
		pLocalize = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Localize" );

	parms.SectionName = SectionName;
	parms.KeyName = KeyName;
	parms.PackageName = PackageName;
	this->ProcessEvent ( pLocalize, &parms, NULL );

	return parms.ReturnValue;
}

void UObject::Warn ( struct FString S )
{
	static UFunction* pWarn = 0;
	UObject_execWarn_Parms parms;

	if ( !pWarn )
		pWarn = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Warn" );

	WORD iNative = pWarn->iNative;
	pWarn->FunctionFlags &= ~FUNC_Native;
	pWarn->iNative = 0;

	parms.S = S;
	this->ProcessEvent ( pWarn, &parms, NULL );

	pWarn->iNative = iNative;
	pWarn->FunctionFlags |= FUNC_Native;
}

#undef Log
void UObject::Log ( struct FString S, struct FName Tag )
{
	static UFunction* pLog = 0;
	UObject_execLog_Parms parms;

	if ( !pLog )
		pLog = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Log" );

	WORD iNative = pLog->iNative;
	pLog->FunctionFlags &= ~FUNC_Native;
	pLog->iNative = 0;

	parms.S = S;
	parms.Tag = Tag;
	this->ProcessEvent ( pLog, &parms, NULL );

	pLog->iNative = iNative;
	pLog->FunctionFlags |= FUNC_Native;
}

struct FQuat UObject::QuatSlerp ( struct FQuat A, struct FQuat B, float Slerp )
{
	static UFunction* pQuatSlerp = 0;
	UObject_execQuatSlerp_Parms parms;

	if ( !pQuatSlerp )
		pQuatSlerp = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.QuatSlerp" );

	parms.A = A;
	parms.B = B;
	parms.Slerp = Slerp;
	this->ProcessEvent ( pQuatSlerp, &parms, NULL );

	return parms.ReturnValue;
}

struct FRotator UObject::QuatToRotator ( struct FQuat A )
{
	static UFunction* pQuatToRotator = 0;
	UObject_execQuatToRotator_Parms parms;

	if ( !pQuatToRotator )
		pQuatToRotator = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.QuatToRotator" );

	parms.A = A;
	this->ProcessEvent ( pQuatToRotator, &parms, NULL );

	return parms.ReturnValue;
}

struct FQuat UObject::QuatFromRotator ( struct FRotator A )
{
	static UFunction* pQuatFromRotator = 0;
	UObject_execQuatFromRotator_Parms parms;

	if ( !pQuatFromRotator )
		pQuatFromRotator = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.QuatFromRotator" );

	parms.A = A;
	this->ProcessEvent ( pQuatFromRotator, &parms, NULL );

	return parms.ReturnValue;
}

struct FQuat UObject::QuatFromAxisAndAngle ( struct FVector Axis, float Angle )
{
	static UFunction* pQuatFromAxisAndAngle = 0;
	UObject_execQuatFromAxisAndAngle_Parms parms;

	if ( !pQuatFromAxisAndAngle )
		pQuatFromAxisAndAngle = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.QuatFromAxisAndAngle" );

	parms.Axis = Axis;
	parms.Angle = Angle;
	this->ProcessEvent ( pQuatFromAxisAndAngle, &parms, NULL );

	return parms.ReturnValue;
}

struct FQuat UObject::QuatFindBetween ( struct FVector A, struct FVector B )
{
	static UFunction* pQuatFindBetween = 0;
	UObject_execQuatFindBetween_Parms parms;

	if ( !pQuatFindBetween )
		pQuatFindBetween = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.QuatFindBetween" );

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pQuatFindBetween, &parms, NULL );

	return parms.ReturnValue;
}

struct FVector UObject::QuatRotateVector ( struct FQuat A, struct FVector B )
{
	static UFunction* pQuatRotateVector = 0;
	UObject_execQuatRotateVector_Parms parms;

	if ( !pQuatRotateVector )
		pQuatRotateVector = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.QuatRotateVector" );

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pQuatRotateVector, &parms, NULL );

	return parms.ReturnValue;
}

struct FQuat UObject::QuatInvert ( struct FQuat A )
{
	static UFunction* pQuatInvert = 0;
	UObject_execQuatInvert_Parms parms;

	if ( !pQuatInvert )
		pQuatInvert = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.QuatInvert" );

	parms.A = A;
	this->ProcessEvent ( pQuatInvert, &parms, NULL );

	return parms.ReturnValue;
}

struct FQuat UObject::QuatProduct ( struct FQuat A, struct FQuat B )
{
	static UFunction* pQuatProduct = 0;
	UObject_execQuatProduct_Parms parms;

	if ( !pQuatProduct )
		pQuatProduct = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.QuatProduct" );

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pQuatProduct, &parms, NULL );

	return parms.ReturnValue;
}

void UObject::InterpCurveGetInputDomain ( struct FInterpCurve curve, float* Min, float* Max )
{
	static UFunction* pInterpCurveGetInputDomain = 0;
	UObject_execInterpCurveGetInputDomain_Parms parms;

	if ( !pInterpCurveGetInputDomain )
		pInterpCurveGetInputDomain = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.InterpCurveGetInputDomain" );

	parms.curve = curve;
	this->ProcessEvent ( pInterpCurveGetInputDomain, &parms, NULL );

	*Min = parms.Min;
	*Max = parms.Max;
}

void UObject::InterpCurveGetOutputRange ( struct FInterpCurve curve, float* Min, float* Max )
{
	static UFunction* pInterpCurveGetOutputRange = 0;
	UObject_execInterpCurveGetOutputRange_Parms parms;

	if ( !pInterpCurveGetOutputRange )
		pInterpCurveGetOutputRange = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.InterpCurveGetOutputRange" );

	parms.curve = curve;
	this->ProcessEvent ( pInterpCurveGetOutputRange, &parms, NULL );

	*Min = parms.Min;
	*Max = parms.Max;
}

float UObject::InterpCurveEval ( struct FInterpCurve curve, float Input )
{
	static UFunction* pInterpCurveEval = 0;
	UObject_execInterpCurveEval_Parms parms;

	if ( !pInterpCurveEval )
		pInterpCurveEval = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.InterpCurveEval" );

	parms.curve = curve;
	parms.Input = Input;
	this->ProcessEvent ( pInterpCurveEval, &parms, NULL );

	return parms.ReturnValue;
}

bool UObject::NotEqual_BtrDoubleInt ( struct FBtrDouble A, int B )
{
	static UFunction* pNotEqual_BtrDoubleInt = 0;
	UObject_execNotEqual_BtrDoubleInt_Parms parms;

	if ( !pNotEqual_BtrDoubleInt )
		pNotEqual_BtrDoubleInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.NotEqual_BtrDoubleInt" );

	WORD iNative = pNotEqual_BtrDoubleInt->iNative;
	pNotEqual_BtrDoubleInt->FunctionFlags &= ~FUNC_Native;
	pNotEqual_BtrDoubleInt->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pNotEqual_BtrDoubleInt, &parms, NULL );

	pNotEqual_BtrDoubleInt->iNative = iNative;
	pNotEqual_BtrDoubleInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::EqualEqual_BtrDoubleInt ( struct FBtrDouble A, int B )
{
	static UFunction* pEqualEqual_BtrDoubleInt = 0;
	UObject_execEqualEqual_BtrDoubleInt_Parms parms;

	if ( !pEqualEqual_BtrDoubleInt )
		pEqualEqual_BtrDoubleInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.EqualEqual_BtrDoubleInt" );

	WORD iNative = pEqualEqual_BtrDoubleInt->iNative;
	pEqualEqual_BtrDoubleInt->FunctionFlags &= ~FUNC_Native;
	pEqualEqual_BtrDoubleInt->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pEqualEqual_BtrDoubleInt, &parms, NULL );

	pEqualEqual_BtrDoubleInt->iNative = iNative;
	pEqualEqual_BtrDoubleInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::Less_BtrDoubleBtrDouble ( struct FBtrDouble A, struct FBtrDouble B )
{
	static UFunction* pLess_BtrDoubleBtrDouble = 0;
	UObject_execLess_BtrDoubleBtrDouble_Parms parms;

	if ( !pLess_BtrDoubleBtrDouble )
		pLess_BtrDoubleBtrDouble = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Less_BtrDoubleBtrDouble" );

	WORD iNative = pLess_BtrDoubleBtrDouble->iNative;
	pLess_BtrDoubleBtrDouble->FunctionFlags &= ~FUNC_Native;
	pLess_BtrDoubleBtrDouble->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pLess_BtrDoubleBtrDouble, &parms, NULL );

	pLess_BtrDoubleBtrDouble->iNative = iNative;
	pLess_BtrDoubleBtrDouble->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FBtrDouble UObject::StringToBtrDouble ( struct FString A )
{
	static UFunction* pStringToBtrDouble = 0;
	UObject_execStringToBtrDouble_Parms parms;

	if ( !pStringToBtrDouble )
		pStringToBtrDouble = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.StringToBtrDouble" );

	WORD iNative = pStringToBtrDouble->iNative;
	pStringToBtrDouble->FunctionFlags &= ~FUNC_Native;
	pStringToBtrDouble->iNative = 0;

	parms.A = A;
	this->ProcessEvent ( pStringToBtrDouble, &parms, NULL );

	pStringToBtrDouble->iNative = iNative;
	pStringToBtrDouble->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

int UObject::BtrDoubleToInt ( struct FBtrDouble A )
{
	static UFunction* pBtrDoubleToInt = 0;
	UObject_execBtrDoubleToInt_Parms parms;

	if ( !pBtrDoubleToInt )
		pBtrDoubleToInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.BtrDoubleToInt" );

	WORD iNative = pBtrDoubleToInt->iNative;
	pBtrDoubleToInt->FunctionFlags &= ~FUNC_Native;
	pBtrDoubleToInt->iNative = 0;

	parms.A = A;
	this->ProcessEvent ( pBtrDoubleToInt, &parms, NULL );

	pBtrDoubleToInt->iNative = iNative;
	pBtrDoubleToInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FBtrDouble UObject::IntToBtrDouble ( int A )
{
	static UFunction* pIntToBtrDouble = 0;
	UObject_execIntToBtrDouble_Parms parms;

	if ( !pIntToBtrDouble )
		pIntToBtrDouble = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.IntToBtrDouble" );

	WORD iNative = pIntToBtrDouble->iNative;
	pIntToBtrDouble->FunctionFlags &= ~FUNC_Native;
	pIntToBtrDouble->iNative = 0;

	parms.A = A;
	this->ProcessEvent ( pIntToBtrDouble, &parms, NULL );

	pIntToBtrDouble->iNative = iNative;
	pIntToBtrDouble->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FString UObject::BtrDoubleGetToStr ( struct FBtrDouble A )
{
	static UFunction* pBtrDoubleGetToStr = 0;
	UObject_execBtrDoubleGetToStr_Parms parms;

	if ( !pBtrDoubleGetToStr )
		pBtrDoubleGetToStr = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.BtrDoubleGetToStr" );

	WORD iNative = pBtrDoubleGetToStr->iNative;
	pBtrDoubleGetToStr->FunctionFlags &= ~FUNC_Native;
	pBtrDoubleGetToStr->iNative = 0;

	parms.A = A;
	this->ProcessEvent ( pBtrDoubleGetToStr, &parms, NULL );

	pBtrDoubleGetToStr->iNative = iNative;
	pBtrDoubleGetToStr->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FBtrDouble UObject::SubtractEqual_BtrDoubleBtrDouble ( struct FBtrDouble B, struct FBtrDouble* A )
{
	static UFunction* pSubtractEqual_BtrDoubleBtrDouble = 0;
	UObject_execSubtractEqual_BtrDoubleBtrDouble_Parms parms;

	if ( !pSubtractEqual_BtrDoubleBtrDouble )
		pSubtractEqual_BtrDoubleBtrDouble = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.SubtractEqual_BtrDoubleBtrDouble" );

	WORD iNative = pSubtractEqual_BtrDoubleBtrDouble->iNative;
	pSubtractEqual_BtrDoubleBtrDouble->FunctionFlags &= ~FUNC_Native;
	pSubtractEqual_BtrDoubleBtrDouble->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pSubtractEqual_BtrDoubleBtrDouble, &parms, NULL );

	pSubtractEqual_BtrDoubleBtrDouble->iNative = iNative;
	pSubtractEqual_BtrDoubleBtrDouble->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

struct FBtrDouble UObject::AddEqual_BtrDoubleBtrDouble ( struct FBtrDouble B, struct FBtrDouble* A )
{
	static UFunction* pAddEqual_BtrDoubleBtrDouble = 0;
	UObject_execAddEqual_BtrDoubleBtrDouble_Parms parms;

	if ( !pAddEqual_BtrDoubleBtrDouble )
		pAddEqual_BtrDoubleBtrDouble = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.AddEqual_BtrDoubleBtrDouble" );

	WORD iNative = pAddEqual_BtrDoubleBtrDouble->iNative;
	pAddEqual_BtrDoubleBtrDouble->FunctionFlags &= ~FUNC_Native;
	pAddEqual_BtrDoubleBtrDouble->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pAddEqual_BtrDoubleBtrDouble, &parms, NULL );

	pAddEqual_BtrDoubleBtrDouble->iNative = iNative;
	pAddEqual_BtrDoubleBtrDouble->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

struct FBtrDouble UObject::DivideEqual_BtrDoubleBtrDouble ( struct FBtrDouble B, struct FBtrDouble* A )
{
	static UFunction* pDivideEqual_BtrDoubleBtrDouble = 0;
	UObject_execDivideEqual_BtrDoubleBtrDouble_Parms parms;

	if ( !pDivideEqual_BtrDoubleBtrDouble )
		pDivideEqual_BtrDoubleBtrDouble = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.DivideEqual_BtrDoubleBtrDouble" );

	WORD iNative = pDivideEqual_BtrDoubleBtrDouble->iNative;
	pDivideEqual_BtrDoubleBtrDouble->FunctionFlags &= ~FUNC_Native;
	pDivideEqual_BtrDoubleBtrDouble->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pDivideEqual_BtrDoubleBtrDouble, &parms, NULL );

	pDivideEqual_BtrDoubleBtrDouble->iNative = iNative;
	pDivideEqual_BtrDoubleBtrDouble->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

struct FBtrDouble UObject::MultiplyEqual_BtrDoubleBtrDouble ( struct FBtrDouble B, struct FBtrDouble* A )
{
	static UFunction* pMultiplyEqual_BtrDoubleBtrDouble = 0;
	UObject_execMultiplyEqual_BtrDoubleBtrDouble_Parms parms;

	if ( !pMultiplyEqual_BtrDoubleBtrDouble )
		pMultiplyEqual_BtrDoubleBtrDouble = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.MultiplyEqual_BtrDoubleBtrDouble" );

	WORD iNative = pMultiplyEqual_BtrDoubleBtrDouble->iNative;
	pMultiplyEqual_BtrDoubleBtrDouble->FunctionFlags &= ~FUNC_Native;
	pMultiplyEqual_BtrDoubleBtrDouble->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pMultiplyEqual_BtrDoubleBtrDouble, &parms, NULL );

	pMultiplyEqual_BtrDoubleBtrDouble->iNative = iNative;
	pMultiplyEqual_BtrDoubleBtrDouble->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

bool UObject::NotEqual_BtrDoubleBtrDouble ( struct FBtrDouble A, struct FBtrDouble B )
{
	static UFunction* pNotEqual_BtrDoubleBtrDouble = 0;
	UObject_execNotEqual_BtrDoubleBtrDouble_Parms parms;

	if ( !pNotEqual_BtrDoubleBtrDouble )
		pNotEqual_BtrDoubleBtrDouble = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.NotEqual_BtrDoubleBtrDouble" );

	WORD iNative = pNotEqual_BtrDoubleBtrDouble->iNative;
	pNotEqual_BtrDoubleBtrDouble->FunctionFlags &= ~FUNC_Native;
	pNotEqual_BtrDoubleBtrDouble->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pNotEqual_BtrDoubleBtrDouble, &parms, NULL );

	pNotEqual_BtrDoubleBtrDouble->iNative = iNative;
	pNotEqual_BtrDoubleBtrDouble->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::EqualEqual_BtrDoubleBtrDouble ( struct FBtrDouble A, struct FBtrDouble B )
{
	static UFunction* pEqualEqual_BtrDoubleBtrDouble = 0;
	UObject_execEqualEqual_BtrDoubleBtrDouble_Parms parms;

	if ( !pEqualEqual_BtrDoubleBtrDouble )
		pEqualEqual_BtrDoubleBtrDouble = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.EqualEqual_BtrDoubleBtrDouble" );

	WORD iNative = pEqualEqual_BtrDoubleBtrDouble->iNative;
	pEqualEqual_BtrDoubleBtrDouble->FunctionFlags &= ~FUNC_Native;
	pEqualEqual_BtrDoubleBtrDouble->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pEqualEqual_BtrDoubleBtrDouble, &parms, NULL );

	pEqualEqual_BtrDoubleBtrDouble->iNative = iNative;
	pEqualEqual_BtrDoubleBtrDouble->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FBtrDouble UObject::Subtract_BtrDoubleFloat ( struct FBtrDouble A, float B )
{
	static UFunction* pSubtract_BtrDoubleFloat = 0;
	UObject_execSubtract_BtrDoubleFloat_Parms parms;

	if ( !pSubtract_BtrDoubleFloat )
		pSubtract_BtrDoubleFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Subtract_BtrDoubleFloat" );

	WORD iNative = pSubtract_BtrDoubleFloat->iNative;
	pSubtract_BtrDoubleFloat->FunctionFlags &= ~FUNC_Native;
	pSubtract_BtrDoubleFloat->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pSubtract_BtrDoubleFloat, &parms, NULL );

	pSubtract_BtrDoubleFloat->iNative = iNative;
	pSubtract_BtrDoubleFloat->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FBtrDouble UObject::Subtract_BtrDoubleInt ( struct FBtrDouble A, int B )
{
	static UFunction* pSubtract_BtrDoubleInt = 0;
	UObject_execSubtract_BtrDoubleInt_Parms parms;

	if ( !pSubtract_BtrDoubleInt )
		pSubtract_BtrDoubleInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Subtract_BtrDoubleInt" );

	WORD iNative = pSubtract_BtrDoubleInt->iNative;
	pSubtract_BtrDoubleInt->FunctionFlags &= ~FUNC_Native;
	pSubtract_BtrDoubleInt->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pSubtract_BtrDoubleInt, &parms, NULL );

	pSubtract_BtrDoubleInt->iNative = iNative;
	pSubtract_BtrDoubleInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FBtrDouble UObject::Subtract_BtrDoubleBtrDouble ( struct FBtrDouble A, struct FBtrDouble B )
{
	static UFunction* pSubtract_BtrDoubleBtrDouble = 0;
	UObject_execSubtract_BtrDoubleBtrDouble_Parms parms;

	if ( !pSubtract_BtrDoubleBtrDouble )
		pSubtract_BtrDoubleBtrDouble = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Subtract_BtrDoubleBtrDouble" );

	WORD iNative = pSubtract_BtrDoubleBtrDouble->iNative;
	pSubtract_BtrDoubleBtrDouble->FunctionFlags &= ~FUNC_Native;
	pSubtract_BtrDoubleBtrDouble->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pSubtract_BtrDoubleBtrDouble, &parms, NULL );

	pSubtract_BtrDoubleBtrDouble->iNative = iNative;
	pSubtract_BtrDoubleBtrDouble->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FBtrDouble UObject::Add_BtrDoubleFloat ( struct FBtrDouble A, float B )
{
	static UFunction* pAdd_BtrDoubleFloat = 0;
	UObject_execAdd_BtrDoubleFloat_Parms parms;

	if ( !pAdd_BtrDoubleFloat )
		pAdd_BtrDoubleFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Add_BtrDoubleFloat" );

	WORD iNative = pAdd_BtrDoubleFloat->iNative;
	pAdd_BtrDoubleFloat->FunctionFlags &= ~FUNC_Native;
	pAdd_BtrDoubleFloat->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pAdd_BtrDoubleFloat, &parms, NULL );

	pAdd_BtrDoubleFloat->iNative = iNative;
	pAdd_BtrDoubleFloat->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FBtrDouble UObject::Add_BtrDoubleInt ( struct FBtrDouble A, int B )
{
	static UFunction* pAdd_BtrDoubleInt = 0;
	UObject_execAdd_BtrDoubleInt_Parms parms;

	if ( !pAdd_BtrDoubleInt )
		pAdd_BtrDoubleInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Add_BtrDoubleInt" );

	WORD iNative = pAdd_BtrDoubleInt->iNative;
	pAdd_BtrDoubleInt->FunctionFlags &= ~FUNC_Native;
	pAdd_BtrDoubleInt->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pAdd_BtrDoubleInt, &parms, NULL );

	pAdd_BtrDoubleInt->iNative = iNative;
	pAdd_BtrDoubleInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FBtrDouble UObject::Add_BtrDoubleBtrDouble ( struct FBtrDouble A, struct FBtrDouble B )
{
	static UFunction* pAdd_BtrDoubleBtrDouble = 0;
	UObject_execAdd_BtrDoubleBtrDouble_Parms parms;

	if ( !pAdd_BtrDoubleBtrDouble )
		pAdd_BtrDoubleBtrDouble = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Add_BtrDoubleBtrDouble" );

	WORD iNative = pAdd_BtrDoubleBtrDouble->iNative;
	pAdd_BtrDoubleBtrDouble->FunctionFlags &= ~FUNC_Native;
	pAdd_BtrDoubleBtrDouble->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pAdd_BtrDoubleBtrDouble, &parms, NULL );

	pAdd_BtrDoubleBtrDouble->iNative = iNative;
	pAdd_BtrDoubleBtrDouble->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FBtrDouble UObject::Divide_BtrDoubleFloat ( struct FBtrDouble A, float B )
{
	static UFunction* pDivide_BtrDoubleFloat = 0;
	UObject_execDivide_BtrDoubleFloat_Parms parms;

	if ( !pDivide_BtrDoubleFloat )
		pDivide_BtrDoubleFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Divide_BtrDoubleFloat" );

	WORD iNative = pDivide_BtrDoubleFloat->iNative;
	pDivide_BtrDoubleFloat->FunctionFlags &= ~FUNC_Native;
	pDivide_BtrDoubleFloat->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pDivide_BtrDoubleFloat, &parms, NULL );

	pDivide_BtrDoubleFloat->iNative = iNative;
	pDivide_BtrDoubleFloat->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FBtrDouble UObject::Divide_BtrDoubleInt ( struct FBtrDouble A, int B )
{
	static UFunction* pDivide_BtrDoubleInt = 0;
	UObject_execDivide_BtrDoubleInt_Parms parms;

	if ( !pDivide_BtrDoubleInt )
		pDivide_BtrDoubleInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Divide_BtrDoubleInt" );

	WORD iNative = pDivide_BtrDoubleInt->iNative;
	pDivide_BtrDoubleInt->FunctionFlags &= ~FUNC_Native;
	pDivide_BtrDoubleInt->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pDivide_BtrDoubleInt, &parms, NULL );

	pDivide_BtrDoubleInt->iNative = iNative;
	pDivide_BtrDoubleInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FBtrDouble UObject::Divide_BtrDoubleBtrDouble ( struct FBtrDouble A, struct FBtrDouble B )
{
	static UFunction* pDivide_BtrDoubleBtrDouble = 0;
	UObject_execDivide_BtrDoubleBtrDouble_Parms parms;

	if ( !pDivide_BtrDoubleBtrDouble )
		pDivide_BtrDoubleBtrDouble = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Divide_BtrDoubleBtrDouble" );

	WORD iNative = pDivide_BtrDoubleBtrDouble->iNative;
	pDivide_BtrDoubleBtrDouble->FunctionFlags &= ~FUNC_Native;
	pDivide_BtrDoubleBtrDouble->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pDivide_BtrDoubleBtrDouble, &parms, NULL );

	pDivide_BtrDoubleBtrDouble->iNative = iNative;
	pDivide_BtrDoubleBtrDouble->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FBtrDouble UObject::Multiply_BtrDoubleFloat ( struct FBtrDouble A, float B )
{
	static UFunction* pMultiply_BtrDoubleFloat = 0;
	UObject_execMultiply_BtrDoubleFloat_Parms parms;

	if ( !pMultiply_BtrDoubleFloat )
		pMultiply_BtrDoubleFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Multiply_BtrDoubleFloat" );

	WORD iNative = pMultiply_BtrDoubleFloat->iNative;
	pMultiply_BtrDoubleFloat->FunctionFlags &= ~FUNC_Native;
	pMultiply_BtrDoubleFloat->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pMultiply_BtrDoubleFloat, &parms, NULL );

	pMultiply_BtrDoubleFloat->iNative = iNative;
	pMultiply_BtrDoubleFloat->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FBtrDouble UObject::Multiply_BtrDoubleInt ( struct FBtrDouble A, int B )
{
	static UFunction* pMultiply_BtrDoubleInt = 0;
	UObject_execMultiply_BtrDoubleInt_Parms parms;

	if ( !pMultiply_BtrDoubleInt )
		pMultiply_BtrDoubleInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Multiply_BtrDoubleInt" );

	WORD iNative = pMultiply_BtrDoubleInt->iNative;
	pMultiply_BtrDoubleInt->FunctionFlags &= ~FUNC_Native;
	pMultiply_BtrDoubleInt->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pMultiply_BtrDoubleInt, &parms, NULL );

	pMultiply_BtrDoubleInt->iNative = iNative;
	pMultiply_BtrDoubleInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FBtrDouble UObject::Multiply_BtrDoubleBtrDouble ( struct FBtrDouble A, struct FBtrDouble B )
{
	static UFunction* pMultiply_BtrDoubleBtrDouble = 0;
	UObject_execMultiply_BtrDoubleBtrDouble_Parms parms;

	if ( !pMultiply_BtrDoubleBtrDouble )
		pMultiply_BtrDoubleBtrDouble = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Multiply_BtrDoubleBtrDouble" );

	WORD iNative = pMultiply_BtrDoubleBtrDouble->iNative;
	pMultiply_BtrDoubleBtrDouble->FunctionFlags &= ~FUNC_Native;
	pMultiply_BtrDoubleBtrDouble->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pMultiply_BtrDoubleBtrDouble, &parms, NULL );

	pMultiply_BtrDoubleBtrDouble->iNative = iNative;
	pMultiply_BtrDoubleBtrDouble->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::NotEqual_NameName ( struct FName A, struct FName B )
{
	static UFunction* pNotEqual_NameName = 0;
	UObject_execNotEqual_NameName_Parms parms;

	if ( !pNotEqual_NameName )
		pNotEqual_NameName = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.NotEqual_NameName" );

	WORD iNative = pNotEqual_NameName->iNative;
	pNotEqual_NameName->FunctionFlags &= ~FUNC_Native;
	pNotEqual_NameName->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pNotEqual_NameName, &parms, NULL );

	pNotEqual_NameName->iNative = iNative;
	pNotEqual_NameName->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::EqualEqual_NameName ( struct FName A, struct FName B )
{
	static UFunction* pEqualEqual_NameName = 0;
	UObject_execEqualEqual_NameName_Parms parms;

	if ( !pEqualEqual_NameName )
		pEqualEqual_NameName = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.EqualEqual_NameName" );

	WORD iNative = pEqualEqual_NameName->iNative;
	pEqualEqual_NameName->FunctionFlags &= ~FUNC_Native;
	pEqualEqual_NameName->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pEqualEqual_NameName, &parms, NULL );

	pEqualEqual_NameName->iNative = iNative;
	pEqualEqual_NameName->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::NotEqual_ObjectObject ( class UObject* A, class UObject* B )
{
	static UFunction* pNotEqual_ObjectObject = 0;
	UObject_execNotEqual_ObjectObject_Parms parms;

	if ( !pNotEqual_ObjectObject )
		pNotEqual_ObjectObject = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.NotEqual_ObjectObject" );

	WORD iNative = pNotEqual_ObjectObject->iNative;
	pNotEqual_ObjectObject->FunctionFlags &= ~FUNC_Native;
	pNotEqual_ObjectObject->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pNotEqual_ObjectObject, &parms, NULL );

	pNotEqual_ObjectObject->iNative = iNative;
	pNotEqual_ObjectObject->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::EqualEqual_ObjectObject ( class UObject* A, class UObject* B )
{
	static UFunction* pEqualEqual_ObjectObject = 0;
	UObject_execEqualEqual_ObjectObject_Parms parms;

	if ( !pEqualEqual_ObjectObject )
		pEqualEqual_ObjectObject = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.EqualEqual_ObjectObject" );

	WORD iNative = pEqualEqual_ObjectObject->iNative;
	pEqualEqual_ObjectObject->FunctionFlags &= ~FUNC_Native;
	pEqualEqual_ObjectObject->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pEqualEqual_ObjectObject, &parms, NULL );

	pEqualEqual_ObjectObject->iNative = iNative;
	pEqualEqual_ObjectObject->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FString UObject::Eval ( bool Condition, struct FString ResultIfTrue, struct FString ResultIfFalse )
{
	static UFunction* pEval = 0;
	UObject_execEval_Parms parms;

	if ( !pEval )
		pEval = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Eval" );

	WORD iNative = pEval->iNative;
	pEval->FunctionFlags &= ~FUNC_Native;
	pEval->iNative = 0;

	parms.Condition = Condition;
	parms.ResultIfTrue = ResultIfTrue;
	parms.ResultIfFalse = ResultIfFalse;
	this->ProcessEvent ( pEval, &parms, NULL );

	pEval->iNative = iNative;
	pEval->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FString UObject::Repl ( struct FString Src, struct FString Match, struct FString With, bool bCaseSensitive )
{
	static UFunction* pRepl = 0;
	UObject_execRepl_Parms parms;

	if ( !pRepl )
		pRepl = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Repl" );

	WORD iNative = pRepl->iNative;
	pRepl->FunctionFlags &= ~FUNC_Native;
	pRepl->iNative = 0;

	parms.Src = Src;
	parms.Match = Match;
	parms.With = With;
	parms.bCaseSensitive = bCaseSensitive;
	this->ProcessEvent ( pRepl, &parms, NULL );

	pRepl->iNative = iNative;
	pRepl->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

int UObject::StrCmp ( struct FString S, struct FString t, int Count, bool bCaseSensitive )
{
	static UFunction* pStrCmp = 0;
	UObject_execStrCmp_Parms parms;

	if ( !pStrCmp )
		pStrCmp = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.StrCmp" );

	WORD iNative = pStrCmp->iNative;
	pStrCmp->FunctionFlags &= ~FUNC_Native;
	pStrCmp->iNative = 0;

	parms.S = S;
	parms.t = t;
	parms.Count = Count;
	parms.bCaseSensitive = bCaseSensitive;
	this->ProcessEvent ( pStrCmp, &parms, NULL );

	pStrCmp->iNative = iNative;
	pStrCmp->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

int UObject::KeyCode ( struct FString S, int i )
{
	static UFunction* pKeyCode = 0;
	UObject_execKeyCode_Parms parms;

	if ( !pKeyCode )
		pKeyCode = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.KeyCode" );

	WORD iNative = pKeyCode->iNative;
	pKeyCode->FunctionFlags &= ~FUNC_Native;
	pKeyCode->iNative = 0;

	parms.S = S;
	parms.i = i;
	this->ProcessEvent ( pKeyCode, &parms, NULL );

	pKeyCode->iNative = iNative;
	pKeyCode->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

int UObject::Split ( struct FString Src, struct FString Divider, class TArray< struct FString >* Parts )
{
	static UFunction* pSplit = 0;
	UObject_execSplit_Parms parms;

	if ( !pSplit )
		pSplit = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Split" );

	WORD iNative = pSplit->iNative;
	pSplit->FunctionFlags &= ~FUNC_Native;
	pSplit->iNative = 0;

	parms.Src = Src;
	parms.Divider = Divider;
	this->ProcessEvent ( pSplit, &parms, NULL );

	pSplit->iNative = iNative;
	pSplit->FunctionFlags |= FUNC_Native;
	*Parts = parms.Parts;
	return parms.ReturnValue;
}

bool UObject::Divide ( struct FString Src, struct FString Divider, struct FString* LeftPart, struct FString* RightPart )
{
	static UFunction* pDivide = 0;
	UObject_execDivide_Parms parms;

	if ( !pDivide )
		pDivide = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Divide" );

	WORD iNative = pDivide->iNative;
	pDivide->FunctionFlags &= ~FUNC_Native;
	pDivide->iNative = 0;

	parms.Src = Src;
	parms.Divider = Divider;
	this->ProcessEvent ( pDivide, &parms, NULL );

	pDivide->iNative = iNative;
	pDivide->FunctionFlags |= FUNC_Native;
	*LeftPart = parms.LeftPart;
	*RightPart = parms.RightPart;
	return parms.ReturnValue;
}

struct FString UObject::Locs ( struct FString S )
{
	static UFunction* pLocs = 0;
	UObject_execLocs_Parms parms;

	if ( !pLocs )
		pLocs = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Locs" );

	WORD iNative = pLocs->iNative;
	pLocs->FunctionFlags &= ~FUNC_Native;
	pLocs->iNative = 0;

	parms.S = S;
	this->ProcessEvent ( pLocs, &parms, NULL );

	pLocs->iNative = iNative;
	pLocs->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

int UObject::Asc ( struct FString S )
{
	static UFunction* pAsc = 0;
	UObject_execAsc_Parms parms;

	if ( !pAsc )
		pAsc = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Asc" );

	WORD iNative = pAsc->iNative;
	pAsc->FunctionFlags &= ~FUNC_Native;
	pAsc->iNative = 0;

	parms.S = S;
	this->ProcessEvent ( pAsc, &parms, NULL );

	pAsc->iNative = iNative;
	pAsc->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FString UObject::Chr ( int i )
{
	static UFunction* pChr = 0;
	UObject_execChr_Parms parms;

	if ( !pChr )
		pChr = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Chr" );

	WORD iNative = pChr->iNative;
	pChr->FunctionFlags &= ~FUNC_Native;
	pChr->iNative = 0;

	parms.i = i;
	this->ProcessEvent ( pChr, &parms, NULL );

	pChr->iNative = iNative;
	pChr->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FString UObject::Caps ( struct FString S )
{
	static UFunction* pCaps = 0;
	UObject_execCaps_Parms parms;

	if ( !pCaps )
		pCaps = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Caps" );

	WORD iNative = pCaps->iNative;
	pCaps->FunctionFlags &= ~FUNC_Native;
	pCaps->iNative = 0;

	parms.S = S;
	this->ProcessEvent ( pCaps, &parms, NULL );

	pCaps->iNative = iNative;
	pCaps->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FString UObject::Right ( struct FString S, int i )
{
	static UFunction* pRight = 0;
	UObject_execRight_Parms parms;

	if ( !pRight )
		pRight = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Right" );

	WORD iNative = pRight->iNative;
	pRight->FunctionFlags &= ~FUNC_Native;
	pRight->iNative = 0;

	parms.S = S;
	parms.i = i;
	this->ProcessEvent ( pRight, &parms, NULL );

	pRight->iNative = iNative;
	pRight->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FString UObject::Left ( struct FString S, int i )
{
	static UFunction* pLeft = 0;
	UObject_execLeft_Parms parms;

	if ( !pLeft )
		pLeft = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Left" );

	WORD iNative = pLeft->iNative;
	pLeft->FunctionFlags &= ~FUNC_Native;
	pLeft->iNative = 0;

	parms.S = S;
	parms.i = i;
	this->ProcessEvent ( pLeft, &parms, NULL );

	pLeft->iNative = iNative;
	pLeft->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FString UObject::Mid ( struct FString S, int i, int j )
{
	static UFunction* pMid = 0;
	UObject_execMid_Parms parms;

	if ( !pMid )
		pMid = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Mid" );

	WORD iNative = pMid->iNative;
	pMid->FunctionFlags &= ~FUNC_Native;
	pMid->iNative = 0;

	parms.S = S;
	parms.i = i;
	parms.j = j;
	this->ProcessEvent ( pMid, &parms, NULL );

	pMid->iNative = iNative;
	pMid->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

int UObject::InStr ( struct FString S, struct FString t )
{
	static UFunction* pInStr = 0;
	UObject_execInStr_Parms parms;

	if ( !pInStr )
		pInStr = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.InStr" );

	WORD iNative = pInStr->iNative;
	pInStr->FunctionFlags &= ~FUNC_Native;
	pInStr->iNative = 0;

	parms.S = S;
	parms.t = t;
	this->ProcessEvent ( pInStr, &parms, NULL );

	pInStr->iNative = iNative;
	pInStr->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

int UObject::Len ( struct FString S )
{
	static UFunction* pLen = 0;
	UObject_execLen_Parms parms;

	if ( !pLen )
		pLen = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Len" );

	WORD iNative = pLen->iNative;
	pLen->FunctionFlags &= ~FUNC_Native;
	pLen->iNative = 0;

	parms.S = S;
	this->ProcessEvent ( pLen, &parms, NULL );

	pLen->iNative = iNative;
	pLen->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FString UObject::SubtractEqual_StrStr ( struct FString B, struct FString* A )
{
	static UFunction* pSubtractEqual_StrStr = 0;
	UObject_execSubtractEqual_StrStr_Parms parms;

	if ( !pSubtractEqual_StrStr )
		pSubtractEqual_StrStr = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.SubtractEqual_StrStr" );

	WORD iNative = pSubtractEqual_StrStr->iNative;
	pSubtractEqual_StrStr->FunctionFlags &= ~FUNC_Native;
	pSubtractEqual_StrStr->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pSubtractEqual_StrStr, &parms, NULL );

	pSubtractEqual_StrStr->iNative = iNative;
	pSubtractEqual_StrStr->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

struct FString UObject::AtEqual_StrStr ( struct FString B, struct FString* A )
{
	static UFunction* pAtEqual_StrStr = 0;
	UObject_execAtEqual_StrStr_Parms parms;

	if ( !pAtEqual_StrStr )
		pAtEqual_StrStr = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.AtEqual_StrStr" );

	WORD iNative = pAtEqual_StrStr->iNative;
	pAtEqual_StrStr->FunctionFlags &= ~FUNC_Native;
	pAtEqual_StrStr->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pAtEqual_StrStr, &parms, NULL );

	pAtEqual_StrStr->iNative = iNative;
	pAtEqual_StrStr->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

struct FString UObject::ConcatEqual_StrStr ( struct FString B, struct FString* A )
{
	static UFunction* pConcatEqual_StrStr = 0;
	UObject_execConcatEqual_StrStr_Parms parms;

	if ( !pConcatEqual_StrStr )
		pConcatEqual_StrStr = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.ConcatEqual_StrStr" );

	WORD iNative = pConcatEqual_StrStr->iNative;
	pConcatEqual_StrStr->FunctionFlags &= ~FUNC_Native;
	pConcatEqual_StrStr->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pConcatEqual_StrStr, &parms, NULL );

	pConcatEqual_StrStr->iNative = iNative;
	pConcatEqual_StrStr->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

bool UObject::ComplementEqual_StrStr ( struct FString A, struct FString B )
{
	static UFunction* pComplementEqual_StrStr = 0;
	UObject_execComplementEqual_StrStr_Parms parms;

	if ( !pComplementEqual_StrStr )
		pComplementEqual_StrStr = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.ComplementEqual_StrStr" );

	WORD iNative = pComplementEqual_StrStr->iNative;
	pComplementEqual_StrStr->FunctionFlags &= ~FUNC_Native;
	pComplementEqual_StrStr->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pComplementEqual_StrStr, &parms, NULL );

	pComplementEqual_StrStr->iNative = iNative;
	pComplementEqual_StrStr->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::NotEqual_StrStr ( struct FString A, struct FString B )
{
	static UFunction* pNotEqual_StrStr = 0;
	UObject_execNotEqual_StrStr_Parms parms;

	if ( !pNotEqual_StrStr )
		pNotEqual_StrStr = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.NotEqual_StrStr" );

	WORD iNative = pNotEqual_StrStr->iNative;
	pNotEqual_StrStr->FunctionFlags &= ~FUNC_Native;
	pNotEqual_StrStr->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pNotEqual_StrStr, &parms, NULL );

	pNotEqual_StrStr->iNative = iNative;
	pNotEqual_StrStr->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::EqualEqual_StrStr ( struct FString A, struct FString B )
{
	static UFunction* pEqualEqual_StrStr = 0;
	UObject_execEqualEqual_StrStr_Parms parms;

	if ( !pEqualEqual_StrStr )
		pEqualEqual_StrStr = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.EqualEqual_StrStr" );

	WORD iNative = pEqualEqual_StrStr->iNative;
	pEqualEqual_StrStr->FunctionFlags &= ~FUNC_Native;
	pEqualEqual_StrStr->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pEqualEqual_StrStr, &parms, NULL );

	pEqualEqual_StrStr->iNative = iNative;
	pEqualEqual_StrStr->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::GreaterEqual_StrStr ( struct FString A, struct FString B )
{
	static UFunction* pGreaterEqual_StrStr = 0;
	UObject_execGreaterEqual_StrStr_Parms parms;

	if ( !pGreaterEqual_StrStr )
		pGreaterEqual_StrStr = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.GreaterEqual_StrStr" );

	WORD iNative = pGreaterEqual_StrStr->iNative;
	pGreaterEqual_StrStr->FunctionFlags &= ~FUNC_Native;
	pGreaterEqual_StrStr->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pGreaterEqual_StrStr, &parms, NULL );

	pGreaterEqual_StrStr->iNative = iNative;
	pGreaterEqual_StrStr->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::LessEqual_StrStr ( struct FString A, struct FString B )
{
	static UFunction* pLessEqual_StrStr = 0;
	UObject_execLessEqual_StrStr_Parms parms;

	if ( !pLessEqual_StrStr )
		pLessEqual_StrStr = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.LessEqual_StrStr" );

	WORD iNative = pLessEqual_StrStr->iNative;
	pLessEqual_StrStr->FunctionFlags &= ~FUNC_Native;
	pLessEqual_StrStr->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pLessEqual_StrStr, &parms, NULL );

	pLessEqual_StrStr->iNative = iNative;
	pLessEqual_StrStr->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::Greater_StrStr ( struct FString A, struct FString B )
{
	static UFunction* pGreater_StrStr = 0;
	UObject_execGreater_StrStr_Parms parms;

	if ( !pGreater_StrStr )
		pGreater_StrStr = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Greater_StrStr" );

	WORD iNative = pGreater_StrStr->iNative;
	pGreater_StrStr->FunctionFlags &= ~FUNC_Native;
	pGreater_StrStr->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pGreater_StrStr, &parms, NULL );

	pGreater_StrStr->iNative = iNative;
	pGreater_StrStr->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::Less_StrStr ( struct FString A, struct FString B )
{
	static UFunction* pLess_StrStr = 0;
	UObject_execLess_StrStr_Parms parms;

	if ( !pLess_StrStr )
		pLess_StrStr = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Less_StrStr" );

	WORD iNative = pLess_StrStr->iNative;
	pLess_StrStr->FunctionFlags &= ~FUNC_Native;
	pLess_StrStr->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pLess_StrStr, &parms, NULL );

	pLess_StrStr->iNative = iNative;
	pLess_StrStr->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FString UObject::At_StrStr ( struct FString A, struct FString B )
{
	static UFunction* pAt_StrStr = 0;
	UObject_execAt_StrStr_Parms parms;

	if ( !pAt_StrStr )
		pAt_StrStr = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.At_StrStr" );

	WORD iNative = pAt_StrStr->iNative;
	pAt_StrStr->FunctionFlags &= ~FUNC_Native;
	pAt_StrStr->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pAt_StrStr, &parms, NULL );

	pAt_StrStr->iNative = iNative;
	pAt_StrStr->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FString UObject::Concat_StrStr ( struct FString A, struct FString B )
{
	static UFunction* pConcat_StrStr = 0;
	UObject_execConcat_StrStr_Parms parms;

	if ( !pConcat_StrStr )
		pConcat_StrStr = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Concat_StrStr" );

	WORD iNative = pConcat_StrStr->iNative;
	pConcat_StrStr->FunctionFlags &= ~FUNC_Native;
	pConcat_StrStr->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pConcat_StrStr, &parms, NULL );

	pConcat_StrStr->iNative = iNative;
	pConcat_StrStr->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::ClockwiseFrom_IntInt ( int A, int B )
{
	static UFunction* pClockwiseFrom_IntInt = 0;
	UObject_execClockwiseFrom_IntInt_Parms parms;

	if ( !pClockwiseFrom_IntInt )
		pClockwiseFrom_IntInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.ClockwiseFrom_IntInt" );

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pClockwiseFrom_IntInt, &parms, NULL );

	return parms.ReturnValue;
}

struct FRotator UObject::Normalize ( struct FRotator Rot )
{
	static UFunction* pNormalize = 0;
	UObject_execNormalize_Parms parms;

	if ( !pNormalize )
		pNormalize = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Normalize" );

	parms.Rot = Rot;
	this->ProcessEvent ( pNormalize, &parms, NULL );

	return parms.ReturnValue;
}

struct FRotator UObject::OrthoRotation ( struct FVector X, struct FVector Y, struct FVector Z )
{
	static UFunction* pOrthoRotation = 0;
	UObject_execOrthoRotation_Parms parms;

	if ( !pOrthoRotation )
		pOrthoRotation = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.OrthoRotation" );

	parms.X = X;
	parms.Y = Y;
	parms.Z = Z;
	this->ProcessEvent ( pOrthoRotation, &parms, NULL );

	return parms.ReturnValue;
}

struct FRotator UObject::RotRand ( bool bRoll )
{
	static UFunction* pRotRand = 0;
	UObject_execRotRand_Parms parms;

	if ( !pRotRand )
		pRotRand = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.RotRand" );

	WORD iNative = pRotRand->iNative;
	pRotRand->FunctionFlags &= ~FUNC_Native;
	pRotRand->iNative = 0;

	parms.bRoll = bRoll;
	this->ProcessEvent ( pRotRand, &parms, NULL );

	pRotRand->iNative = iNative;
	pRotRand->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

void UObject::GetUnAxes ( struct FRotator A, struct FVector* X, struct FVector* Y, struct FVector* Z )
{
	static UFunction* pGetUnAxes = 0;
	UObject_execGetUnAxes_Parms parms;

	if ( !pGetUnAxes )
		pGetUnAxes = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.GetUnAxes" );

	WORD iNative = pGetUnAxes->iNative;
	pGetUnAxes->FunctionFlags &= ~FUNC_Native;
	pGetUnAxes->iNative = 0;

	parms.A = A;
	this->ProcessEvent ( pGetUnAxes, &parms, NULL );

	pGetUnAxes->iNative = iNative;
	pGetUnAxes->FunctionFlags |= FUNC_Native;
	*X = parms.X;
	*Y = parms.Y;
	*Z = parms.Z;
}

void UObject::GetAxes ( struct FRotator A, struct FVector* X, struct FVector* Y, struct FVector* Z )
{
	static UFunction* pGetAxes = 0;
	UObject_execGetAxes_Parms parms;

	if ( !pGetAxes )
		pGetAxes = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.GetAxes" );

	WORD iNative = pGetAxes->iNative;
	pGetAxes->FunctionFlags &= ~FUNC_Native;
	pGetAxes->iNative = 0;

	parms.A = A;
	this->ProcessEvent ( pGetAxes, &parms, NULL );

	pGetAxes->iNative = iNative;
	pGetAxes->FunctionFlags |= FUNC_Native;
	*X = parms.X;
	*Y = parms.Y;
	*Z = parms.Z;
}

struct FRotator UObject::SubtractEqual_RotatorRotator ( struct FRotator B, struct FRotator* A )
{
	static UFunction* pSubtractEqual_RotatorRotator = 0;
	UObject_execSubtractEqual_RotatorRotator_Parms parms;

	if ( !pSubtractEqual_RotatorRotator )
		pSubtractEqual_RotatorRotator = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.SubtractEqual_RotatorRotator" );

	WORD iNative = pSubtractEqual_RotatorRotator->iNative;
	pSubtractEqual_RotatorRotator->FunctionFlags &= ~FUNC_Native;
	pSubtractEqual_RotatorRotator->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pSubtractEqual_RotatorRotator, &parms, NULL );

	pSubtractEqual_RotatorRotator->iNative = iNative;
	pSubtractEqual_RotatorRotator->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

struct FRotator UObject::AddEqual_RotatorRotator ( struct FRotator B, struct FRotator* A )
{
	static UFunction* pAddEqual_RotatorRotator = 0;
	UObject_execAddEqual_RotatorRotator_Parms parms;

	if ( !pAddEqual_RotatorRotator )
		pAddEqual_RotatorRotator = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.AddEqual_RotatorRotator" );

	WORD iNative = pAddEqual_RotatorRotator->iNative;
	pAddEqual_RotatorRotator->FunctionFlags &= ~FUNC_Native;
	pAddEqual_RotatorRotator->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pAddEqual_RotatorRotator, &parms, NULL );

	pAddEqual_RotatorRotator->iNative = iNative;
	pAddEqual_RotatorRotator->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

struct FRotator UObject::Subtract_RotatorRotator ( struct FRotator A, struct FRotator B )
{
	static UFunction* pSubtract_RotatorRotator = 0;
	UObject_execSubtract_RotatorRotator_Parms parms;

	if ( !pSubtract_RotatorRotator )
		pSubtract_RotatorRotator = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Subtract_RotatorRotator" );

	WORD iNative = pSubtract_RotatorRotator->iNative;
	pSubtract_RotatorRotator->FunctionFlags &= ~FUNC_Native;
	pSubtract_RotatorRotator->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pSubtract_RotatorRotator, &parms, NULL );

	pSubtract_RotatorRotator->iNative = iNative;
	pSubtract_RotatorRotator->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FRotator UObject::Add_RotatorRotator ( struct FRotator A, struct FRotator B )
{
	static UFunction* pAdd_RotatorRotator = 0;
	UObject_execAdd_RotatorRotator_Parms parms;

	if ( !pAdd_RotatorRotator )
		pAdd_RotatorRotator = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Add_RotatorRotator" );

	WORD iNative = pAdd_RotatorRotator->iNative;
	pAdd_RotatorRotator->FunctionFlags &= ~FUNC_Native;
	pAdd_RotatorRotator->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pAdd_RotatorRotator, &parms, NULL );

	pAdd_RotatorRotator->iNative = iNative;
	pAdd_RotatorRotator->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FRotator UObject::DivideEqual_RotatorFloat ( float B, struct FRotator* A )
{
	static UFunction* pDivideEqual_RotatorFloat = 0;
	UObject_execDivideEqual_RotatorFloat_Parms parms;

	if ( !pDivideEqual_RotatorFloat )
		pDivideEqual_RotatorFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.DivideEqual_RotatorFloat" );

	WORD iNative = pDivideEqual_RotatorFloat->iNative;
	pDivideEqual_RotatorFloat->FunctionFlags &= ~FUNC_Native;
	pDivideEqual_RotatorFloat->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pDivideEqual_RotatorFloat, &parms, NULL );

	pDivideEqual_RotatorFloat->iNative = iNative;
	pDivideEqual_RotatorFloat->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

struct FRotator UObject::MultiplyEqual_RotatorFloat ( float B, struct FRotator* A )
{
	static UFunction* pMultiplyEqual_RotatorFloat = 0;
	UObject_execMultiplyEqual_RotatorFloat_Parms parms;

	if ( !pMultiplyEqual_RotatorFloat )
		pMultiplyEqual_RotatorFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.MultiplyEqual_RotatorFloat" );

	WORD iNative = pMultiplyEqual_RotatorFloat->iNative;
	pMultiplyEqual_RotatorFloat->FunctionFlags &= ~FUNC_Native;
	pMultiplyEqual_RotatorFloat->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pMultiplyEqual_RotatorFloat, &parms, NULL );

	pMultiplyEqual_RotatorFloat->iNative = iNative;
	pMultiplyEqual_RotatorFloat->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

struct FRotator UObject::Divide_RotatorFloat ( struct FRotator A, float B )
{
	static UFunction* pDivide_RotatorFloat = 0;
	UObject_execDivide_RotatorFloat_Parms parms;

	if ( !pDivide_RotatorFloat )
		pDivide_RotatorFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Divide_RotatorFloat" );

	WORD iNative = pDivide_RotatorFloat->iNative;
	pDivide_RotatorFloat->FunctionFlags &= ~FUNC_Native;
	pDivide_RotatorFloat->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pDivide_RotatorFloat, &parms, NULL );

	pDivide_RotatorFloat->iNative = iNative;
	pDivide_RotatorFloat->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FRotator UObject::Multiply_FloatRotator ( float A, struct FRotator B )
{
	static UFunction* pMultiply_FloatRotator = 0;
	UObject_execMultiply_FloatRotator_Parms parms;

	if ( !pMultiply_FloatRotator )
		pMultiply_FloatRotator = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Multiply_FloatRotator" );

	WORD iNative = pMultiply_FloatRotator->iNative;
	pMultiply_FloatRotator->FunctionFlags &= ~FUNC_Native;
	pMultiply_FloatRotator->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pMultiply_FloatRotator, &parms, NULL );

	pMultiply_FloatRotator->iNative = iNative;
	pMultiply_FloatRotator->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FRotator UObject::Multiply_RotatorFloat ( struct FRotator A, float B )
{
	static UFunction* pMultiply_RotatorFloat = 0;
	UObject_execMultiply_RotatorFloat_Parms parms;

	if ( !pMultiply_RotatorFloat )
		pMultiply_RotatorFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Multiply_RotatorFloat" );

	WORD iNative = pMultiply_RotatorFloat->iNative;
	pMultiply_RotatorFloat->FunctionFlags &= ~FUNC_Native;
	pMultiply_RotatorFloat->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pMultiply_RotatorFloat, &parms, NULL );

	pMultiply_RotatorFloat->iNative = iNative;
	pMultiply_RotatorFloat->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::NotEqual_RotatorRotator ( struct FRotator A, struct FRotator B )
{
	static UFunction* pNotEqual_RotatorRotator = 0;
	UObject_execNotEqual_RotatorRotator_Parms parms;

	if ( !pNotEqual_RotatorRotator )
		pNotEqual_RotatorRotator = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.NotEqual_RotatorRotator" );

	WORD iNative = pNotEqual_RotatorRotator->iNative;
	pNotEqual_RotatorRotator->FunctionFlags &= ~FUNC_Native;
	pNotEqual_RotatorRotator->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pNotEqual_RotatorRotator, &parms, NULL );

	pNotEqual_RotatorRotator->iNative = iNative;
	pNotEqual_RotatorRotator->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::EqualEqual_RotatorRotator ( struct FRotator A, struct FRotator B )
{
	static UFunction* pEqualEqual_RotatorRotator = 0;
	UObject_execEqualEqual_RotatorRotator_Parms parms;

	if ( !pEqualEqual_RotatorRotator )
		pEqualEqual_RotatorRotator = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.EqualEqual_RotatorRotator" );

	WORD iNative = pEqualEqual_RotatorRotator->iNative;
	pEqualEqual_RotatorRotator->FunctionFlags &= ~FUNC_Native;
	pEqualEqual_RotatorRotator->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pEqualEqual_RotatorRotator, &parms, NULL );

	pEqualEqual_RotatorRotator->iNative = iNative;
	pEqualEqual_RotatorRotator->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FVector UObject::MirrorVectorByNormal ( struct FVector Vect, struct FVector Normal )
{
	static UFunction* pMirrorVectorByNormal = 0;
	UObject_execMirrorVectorByNormal_Parms parms;

	if ( !pMirrorVectorByNormal )
		pMirrorVectorByNormal = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.MirrorVectorByNormal" );

	WORD iNative = pMirrorVectorByNormal->iNative;
	pMirrorVectorByNormal->FunctionFlags &= ~FUNC_Native;
	pMirrorVectorByNormal->iNative = 0;

	parms.Vect = Vect;
	parms.Normal = Normal;
	this->ProcessEvent ( pMirrorVectorByNormal, &parms, NULL );

	pMirrorVectorByNormal->iNative = iNative;
	pMirrorVectorByNormal->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FVector UObject::VRand (  )
{
	static UFunction* pVRand = 0;
	UObject_execVRand_Parms parms;

	if ( !pVRand )
		pVRand = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.VRand" );

	WORD iNative = pVRand->iNative;
	pVRand->FunctionFlags &= ~FUNC_Native;
	pVRand->iNative = 0;

	this->ProcessEvent ( pVRand, &parms, NULL );

	pVRand->iNative = iNative;
	pVRand->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

void UObject::Invert ( struct FVector* X, struct FVector* Y, struct FVector* Z )
{
	static UFunction* pInvert = 0;
	UObject_execInvert_Parms parms;

	if ( !pInvert )
		pInvert = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Invert" );

	WORD iNative = pInvert->iNative;
	pInvert->FunctionFlags &= ~FUNC_Native;
	pInvert->iNative = 0;

	parms.X = *X;
	parms.Y = *Y;
	parms.Z = *Z;
	this->ProcessEvent ( pInvert, &parms, NULL );

	pInvert->iNative = iNative;
	pInvert->FunctionFlags |= FUNC_Native;
	*X = parms.X;
	*Y = parms.Y;
	*Z = parms.Z;
}

struct FVector UObject::Normal ( struct FVector A )
{
	static UFunction* pNormal = 0;
	UObject_execNormal_Parms parms;

	if ( !pNormal )
		pNormal = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Normal" );

	WORD iNative = pNormal->iNative;
	pNormal->FunctionFlags &= ~FUNC_Native;
	pNormal->iNative = 0;

	parms.A = A;
	this->ProcessEvent ( pNormal, &parms, NULL );

	pNormal->iNative = iNative;
	pNormal->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::VSize ( struct FVector A )
{
	static UFunction* pVSize = 0;
	UObject_execVSize_Parms parms;

	if ( !pVSize )
		pVSize = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.VSize" );

	WORD iNative = pVSize->iNative;
	pVSize->FunctionFlags &= ~FUNC_Native;
	pVSize->iNative = 0;

	parms.A = A;
	this->ProcessEvent ( pVSize, &parms, NULL );

	pVSize->iNative = iNative;
	pVSize->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FVector UObject::SubtractEqual_VectorVector ( struct FVector B, struct FVector* A )
{
	static UFunction* pSubtractEqual_VectorVector = 0;
	UObject_execSubtractEqual_VectorVector_Parms parms;

	if ( !pSubtractEqual_VectorVector )
		pSubtractEqual_VectorVector = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.SubtractEqual_VectorVector" );

	WORD iNative = pSubtractEqual_VectorVector->iNative;
	pSubtractEqual_VectorVector->FunctionFlags &= ~FUNC_Native;
	pSubtractEqual_VectorVector->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pSubtractEqual_VectorVector, &parms, NULL );

	pSubtractEqual_VectorVector->iNative = iNative;
	pSubtractEqual_VectorVector->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

struct FVector UObject::AddEqual_VectorVector ( struct FVector B, struct FVector* A )
{
	static UFunction* pAddEqual_VectorVector = 0;
	UObject_execAddEqual_VectorVector_Parms parms;

	if ( !pAddEqual_VectorVector )
		pAddEqual_VectorVector = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.AddEqual_VectorVector" );

	WORD iNative = pAddEqual_VectorVector->iNative;
	pAddEqual_VectorVector->FunctionFlags &= ~FUNC_Native;
	pAddEqual_VectorVector->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pAddEqual_VectorVector, &parms, NULL );

	pAddEqual_VectorVector->iNative = iNative;
	pAddEqual_VectorVector->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

struct FVector UObject::DivideEqual_VectorFloat ( float B, struct FVector* A )
{
	static UFunction* pDivideEqual_VectorFloat = 0;
	UObject_execDivideEqual_VectorFloat_Parms parms;

	if ( !pDivideEqual_VectorFloat )
		pDivideEqual_VectorFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.DivideEqual_VectorFloat" );

	WORD iNative = pDivideEqual_VectorFloat->iNative;
	pDivideEqual_VectorFloat->FunctionFlags &= ~FUNC_Native;
	pDivideEqual_VectorFloat->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pDivideEqual_VectorFloat, &parms, NULL );

	pDivideEqual_VectorFloat->iNative = iNative;
	pDivideEqual_VectorFloat->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

struct FVector UObject::MultiplyEqual_VectorVector ( struct FVector B, struct FVector* A )
{
	static UFunction* pMultiplyEqual_VectorVector = 0;
	UObject_execMultiplyEqual_VectorVector_Parms parms;

	if ( !pMultiplyEqual_VectorVector )
		pMultiplyEqual_VectorVector = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.MultiplyEqual_VectorVector" );

	WORD iNative = pMultiplyEqual_VectorVector->iNative;
	pMultiplyEqual_VectorVector->FunctionFlags &= ~FUNC_Native;
	pMultiplyEqual_VectorVector->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pMultiplyEqual_VectorVector, &parms, NULL );

	pMultiplyEqual_VectorVector->iNative = iNative;
	pMultiplyEqual_VectorVector->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

struct FVector UObject::MultiplyEqual_VectorFloat ( float B, struct FVector* A )
{
	static UFunction* pMultiplyEqual_VectorFloat = 0;
	UObject_execMultiplyEqual_VectorFloat_Parms parms;

	if ( !pMultiplyEqual_VectorFloat )
		pMultiplyEqual_VectorFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.MultiplyEqual_VectorFloat" );

	WORD iNative = pMultiplyEqual_VectorFloat->iNative;
	pMultiplyEqual_VectorFloat->FunctionFlags &= ~FUNC_Native;
	pMultiplyEqual_VectorFloat->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pMultiplyEqual_VectorFloat, &parms, NULL );

	pMultiplyEqual_VectorFloat->iNative = iNative;
	pMultiplyEqual_VectorFloat->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

struct FVector UObject::Cross_VectorVector ( struct FVector A, struct FVector B )
{
	static UFunction* pCross_VectorVector = 0;
	UObject_execCross_VectorVector_Parms parms;

	if ( !pCross_VectorVector )
		pCross_VectorVector = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Cross_VectorVector" );

	WORD iNative = pCross_VectorVector->iNative;
	pCross_VectorVector->FunctionFlags &= ~FUNC_Native;
	pCross_VectorVector->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pCross_VectorVector, &parms, NULL );

	pCross_VectorVector->iNative = iNative;
	pCross_VectorVector->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::Dot_VectorVector ( struct FVector A, struct FVector B )
{
	static UFunction* pDot_VectorVector = 0;
	UObject_execDot_VectorVector_Parms parms;

	if ( !pDot_VectorVector )
		pDot_VectorVector = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Dot_VectorVector" );

	WORD iNative = pDot_VectorVector->iNative;
	pDot_VectorVector->FunctionFlags &= ~FUNC_Native;
	pDot_VectorVector->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pDot_VectorVector, &parms, NULL );

	pDot_VectorVector->iNative = iNative;
	pDot_VectorVector->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::NotEqual_VectorVector ( struct FVector A, struct FVector B )
{
	static UFunction* pNotEqual_VectorVector = 0;
	UObject_execNotEqual_VectorVector_Parms parms;

	if ( !pNotEqual_VectorVector )
		pNotEqual_VectorVector = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.NotEqual_VectorVector" );

	WORD iNative = pNotEqual_VectorVector->iNative;
	pNotEqual_VectorVector->FunctionFlags &= ~FUNC_Native;
	pNotEqual_VectorVector->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pNotEqual_VectorVector, &parms, NULL );

	pNotEqual_VectorVector->iNative = iNative;
	pNotEqual_VectorVector->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::EqualEqual_VectorVector ( struct FVector A, struct FVector B )
{
	static UFunction* pEqualEqual_VectorVector = 0;
	UObject_execEqualEqual_VectorVector_Parms parms;

	if ( !pEqualEqual_VectorVector )
		pEqualEqual_VectorVector = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.EqualEqual_VectorVector" );

	WORD iNative = pEqualEqual_VectorVector->iNative;
	pEqualEqual_VectorVector->FunctionFlags &= ~FUNC_Native;
	pEqualEqual_VectorVector->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pEqualEqual_VectorVector, &parms, NULL );

	pEqualEqual_VectorVector->iNative = iNative;
	pEqualEqual_VectorVector->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FVector UObject::GreaterGreater_VectorRotator ( struct FVector A, struct FRotator B )
{
	static UFunction* pGreaterGreater_VectorRotator = 0;
	UObject_execGreaterGreater_VectorRotator_Parms parms;

	if ( !pGreaterGreater_VectorRotator )
		pGreaterGreater_VectorRotator = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.GreaterGreater_VectorRotator" );

	WORD iNative = pGreaterGreater_VectorRotator->iNative;
	pGreaterGreater_VectorRotator->FunctionFlags &= ~FUNC_Native;
	pGreaterGreater_VectorRotator->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pGreaterGreater_VectorRotator, &parms, NULL );

	pGreaterGreater_VectorRotator->iNative = iNative;
	pGreaterGreater_VectorRotator->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FVector UObject::LessLess_VectorRotator ( struct FVector A, struct FRotator B )
{
	static UFunction* pLessLess_VectorRotator = 0;
	UObject_execLessLess_VectorRotator_Parms parms;

	if ( !pLessLess_VectorRotator )
		pLessLess_VectorRotator = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.LessLess_VectorRotator" );

	WORD iNative = pLessLess_VectorRotator->iNative;
	pLessLess_VectorRotator->FunctionFlags &= ~FUNC_Native;
	pLessLess_VectorRotator->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pLessLess_VectorRotator, &parms, NULL );

	pLessLess_VectorRotator->iNative = iNative;
	pLessLess_VectorRotator->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FVector UObject::Subtract_VectorVector ( struct FVector A, struct FVector B )
{
	static UFunction* pSubtract_VectorVector = 0;
	UObject_execSubtract_VectorVector_Parms parms;

	if ( !pSubtract_VectorVector )
		pSubtract_VectorVector = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Subtract_VectorVector" );

	WORD iNative = pSubtract_VectorVector->iNative;
	pSubtract_VectorVector->FunctionFlags &= ~FUNC_Native;
	pSubtract_VectorVector->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pSubtract_VectorVector, &parms, NULL );

	pSubtract_VectorVector->iNative = iNative;
	pSubtract_VectorVector->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FVector UObject::Add_VectorVector ( struct FVector A, struct FVector B )
{
	static UFunction* pAdd_VectorVector = 0;
	UObject_execAdd_VectorVector_Parms parms;

	if ( !pAdd_VectorVector )
		pAdd_VectorVector = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Add_VectorVector" );

	WORD iNative = pAdd_VectorVector->iNative;
	pAdd_VectorVector->FunctionFlags &= ~FUNC_Native;
	pAdd_VectorVector->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pAdd_VectorVector, &parms, NULL );

	pAdd_VectorVector->iNative = iNative;
	pAdd_VectorVector->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FVector UObject::Divide_VectorFloat ( struct FVector A, float B )
{
	static UFunction* pDivide_VectorFloat = 0;
	UObject_execDivide_VectorFloat_Parms parms;

	if ( !pDivide_VectorFloat )
		pDivide_VectorFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Divide_VectorFloat" );

	WORD iNative = pDivide_VectorFloat->iNative;
	pDivide_VectorFloat->FunctionFlags &= ~FUNC_Native;
	pDivide_VectorFloat->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pDivide_VectorFloat, &parms, NULL );

	pDivide_VectorFloat->iNative = iNative;
	pDivide_VectorFloat->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FVector UObject::Multiply_VectorVector ( struct FVector A, struct FVector B )
{
	static UFunction* pMultiply_VectorVector = 0;
	UObject_execMultiply_VectorVector_Parms parms;

	if ( !pMultiply_VectorVector )
		pMultiply_VectorVector = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Multiply_VectorVector" );

	WORD iNative = pMultiply_VectorVector->iNative;
	pMultiply_VectorVector->FunctionFlags &= ~FUNC_Native;
	pMultiply_VectorVector->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pMultiply_VectorVector, &parms, NULL );

	pMultiply_VectorVector->iNative = iNative;
	pMultiply_VectorVector->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FVector UObject::Multiply_FloatVector ( float A, struct FVector B )
{
	static UFunction* pMultiply_FloatVector = 0;
	UObject_execMultiply_FloatVector_Parms parms;

	if ( !pMultiply_FloatVector )
		pMultiply_FloatVector = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Multiply_FloatVector" );

	WORD iNative = pMultiply_FloatVector->iNative;
	pMultiply_FloatVector->FunctionFlags &= ~FUNC_Native;
	pMultiply_FloatVector->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pMultiply_FloatVector, &parms, NULL );

	pMultiply_FloatVector->iNative = iNative;
	pMultiply_FloatVector->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FVector UObject::Multiply_VectorFloat ( struct FVector A, float B )
{
	static UFunction* pMultiply_VectorFloat = 0;
	UObject_execMultiply_VectorFloat_Parms parms;

	if ( !pMultiply_VectorFloat )
		pMultiply_VectorFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Multiply_VectorFloat" );

	WORD iNative = pMultiply_VectorFloat->iNative;
	pMultiply_VectorFloat->FunctionFlags &= ~FUNC_Native;
	pMultiply_VectorFloat->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pMultiply_VectorFloat, &parms, NULL );

	pMultiply_VectorFloat->iNative = iNative;
	pMultiply_VectorFloat->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

struct FVector UObject::Subtract_PreVector ( struct FVector A )
{
	static UFunction* pSubtract_PreVector = 0;
	UObject_execSubtract_PreVector_Parms parms;

	if ( !pSubtract_PreVector )
		pSubtract_PreVector = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Subtract_PreVector" );

	WORD iNative = pSubtract_PreVector->iNative;
	pSubtract_PreVector->FunctionFlags &= ~FUNC_Native;
	pSubtract_PreVector->iNative = 0;

	parms.A = A;
	this->ProcessEvent ( pSubtract_PreVector, &parms, NULL );

	pSubtract_PreVector->iNative = iNative;
	pSubtract_PreVector->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::Round ( float A )
{
	static UFunction* pRound = 0;
	UObject_execRound_Parms parms;

	if ( !pRound )
		pRound = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Round" );

	WORD iNative = pRound->iNative;
	pRound->FunctionFlags &= ~FUNC_Native;
	pRound->iNative = 0;

	parms.A = A;
	this->ProcessEvent ( pRound, &parms, NULL );

	pRound->iNative = iNative;
	pRound->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::Ceil ( float A )
{
	static UFunction* pCeil = 0;
	UObject_execCeil_Parms parms;

	if ( !pCeil )
		pCeil = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Ceil" );

	WORD iNative = pCeil->iNative;
	pCeil->FunctionFlags &= ~FUNC_Native;
	pCeil->iNative = 0;

	parms.A = A;
	this->ProcessEvent ( pCeil, &parms, NULL );

	pCeil->iNative = iNative;
	pCeil->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::Smerp ( float Alpha, float A, float B )
{
	static UFunction* pSmerp = 0;
	UObject_execSmerp_Parms parms;

	if ( !pSmerp )
		pSmerp = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Smerp" );

	WORD iNative = pSmerp->iNative;
	pSmerp->FunctionFlags &= ~FUNC_Native;
	pSmerp->iNative = 0;

	parms.Alpha = Alpha;
	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pSmerp, &parms, NULL );

	pSmerp->iNative = iNative;
	pSmerp->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::Lerp ( float Alpha, float A, float B, bool bClampRange )
{
	static UFunction* pLerp = 0;
	UObject_execLerp_Parms parms;

	if ( !pLerp )
		pLerp = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Lerp" );

	WORD iNative = pLerp->iNative;
	pLerp->FunctionFlags &= ~FUNC_Native;
	pLerp->iNative = 0;

	parms.Alpha = Alpha;
	parms.A = A;
	parms.B = B;
	parms.bClampRange = bClampRange;
	this->ProcessEvent ( pLerp, &parms, NULL );

	pLerp->iNative = iNative;
	pLerp->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::FClamp ( float V, float A, float B )
{
	static UFunction* pFClamp = 0;
	UObject_execFClamp_Parms parms;

	if ( !pFClamp )
		pFClamp = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.FClamp" );

	WORD iNative = pFClamp->iNative;
	pFClamp->FunctionFlags &= ~FUNC_Native;
	pFClamp->iNative = 0;

	parms.V = V;
	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pFClamp, &parms, NULL );

	pFClamp->iNative = iNative;
	pFClamp->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::FMax ( float A, float B )
{
	static UFunction* pFMax = 0;
	UObject_execFMax_Parms parms;

	if ( !pFMax )
		pFMax = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.FMax" );

	WORD iNative = pFMax->iNative;
	pFMax->FunctionFlags &= ~FUNC_Native;
	pFMax->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pFMax, &parms, NULL );

	pFMax->iNative = iNative;
	pFMax->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::FMin ( float A, float B )
{
	static UFunction* pFMin = 0;
	UObject_execFMin_Parms parms;

	if ( !pFMin )
		pFMin = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.FMin" );

	WORD iNative = pFMin->iNative;
	pFMin->FunctionFlags &= ~FUNC_Native;
	pFMin->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pFMin, &parms, NULL );

	pFMin->iNative = iNative;
	pFMin->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::FRand (  )
{
	static UFunction* pFRand = 0;
	UObject_execFRand_Parms parms;

	if ( !pFRand )
		pFRand = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.FRand" );

	WORD iNative = pFRand->iNative;
	pFRand->FunctionFlags &= ~FUNC_Native;
	pFRand->iNative = 0;

	this->ProcessEvent ( pFRand, &parms, NULL );

	pFRand->iNative = iNative;
	pFRand->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::Square ( float A )
{
	static UFunction* pSquare = 0;
	UObject_execSquare_Parms parms;

	if ( !pSquare )
		pSquare = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Square" );

	WORD iNative = pSquare->iNative;
	pSquare->FunctionFlags &= ~FUNC_Native;
	pSquare->iNative = 0;

	parms.A = A;
	this->ProcessEvent ( pSquare, &parms, NULL );

	pSquare->iNative = iNative;
	pSquare->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::Sqrt ( float A )
{
	static UFunction* pSqrt = 0;
	UObject_execSqrt_Parms parms;

	if ( !pSqrt )
		pSqrt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Sqrt" );

	WORD iNative = pSqrt->iNative;
	pSqrt->FunctionFlags &= ~FUNC_Native;
	pSqrt->iNative = 0;

	parms.A = A;
	this->ProcessEvent ( pSqrt, &parms, NULL );

	pSqrt->iNative = iNative;
	pSqrt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::Loge ( float A )
{
	static UFunction* pLoge = 0;
	UObject_execLoge_Parms parms;

	if ( !pLoge )
		pLoge = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Loge" );

	WORD iNative = pLoge->iNative;
	pLoge->FunctionFlags &= ~FUNC_Native;
	pLoge->iNative = 0;

	parms.A = A;
	this->ProcessEvent ( pLoge, &parms, NULL );

	pLoge->iNative = iNative;
	pLoge->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::Exp ( float A )
{
	static UFunction* pExp = 0;
	UObject_execExp_Parms parms;

	if ( !pExp )
		pExp = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Exp" );

	WORD iNative = pExp->iNative;
	pExp->FunctionFlags &= ~FUNC_Native;
	pExp->iNative = 0;

	parms.A = A;
	this->ProcessEvent ( pExp, &parms, NULL );

	pExp->iNative = iNative;
	pExp->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::Atan ( float A, float B )
{
	static UFunction* pAtan = 0;
	UObject_execAtan_Parms parms;

	if ( !pAtan )
		pAtan = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Atan" );

	WORD iNative = pAtan->iNative;
	pAtan->FunctionFlags &= ~FUNC_Native;
	pAtan->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pAtan, &parms, NULL );

	pAtan->iNative = iNative;
	pAtan->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::Tan ( float A )
{
	static UFunction* pTan = 0;
	UObject_execTan_Parms parms;

	if ( !pTan )
		pTan = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Tan" );

	WORD iNative = pTan->iNative;
	pTan->FunctionFlags &= ~FUNC_Native;
	pTan->iNative = 0;

	parms.A = A;
	this->ProcessEvent ( pTan, &parms, NULL );

	pTan->iNative = iNative;
	pTan->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::Acos ( float A )
{
	static UFunction* pAcos = 0;
	UObject_execAcos_Parms parms;

	if ( !pAcos )
		pAcos = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Acos" );

	parms.A = A;
	this->ProcessEvent ( pAcos, &parms, NULL );

	return parms.ReturnValue;
}

float UObject::Cos ( float A )
{
	static UFunction* pCos = 0;
	UObject_execCos_Parms parms;

	if ( !pCos )
		pCos = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Cos" );

	WORD iNative = pCos->iNative;
	pCos->FunctionFlags &= ~FUNC_Native;
	pCos->iNative = 0;

	parms.A = A;
	this->ProcessEvent ( pCos, &parms, NULL );

	pCos->iNative = iNative;
	pCos->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::Asin ( float A )
{
	static UFunction* pAsin = 0;
	UObject_execAsin_Parms parms;

	if ( !pAsin )
		pAsin = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Asin" );

	parms.A = A;
	this->ProcessEvent ( pAsin, &parms, NULL );

	return parms.ReturnValue;
}

float UObject::Sin ( float A )
{
	static UFunction* pSin = 0;
	UObject_execSin_Parms parms;

	if ( !pSin )
		pSin = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Sin" );

	WORD iNative = pSin->iNative;
	pSin->FunctionFlags &= ~FUNC_Native;
	pSin->iNative = 0;

	parms.A = A;
	this->ProcessEvent ( pSin, &parms, NULL );

	pSin->iNative = iNative;
	pSin->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::Abs ( float A )
{
	static UFunction* pAbs = 0;
	UObject_execAbs_Parms parms;

	if ( !pAbs )
		pAbs = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Abs" );

	WORD iNative = pAbs->iNative;
	pAbs->FunctionFlags &= ~FUNC_Native;
	pAbs->iNative = 0;

	parms.A = A;
	this->ProcessEvent ( pAbs, &parms, NULL );

	pAbs->iNative = iNative;
	pAbs->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::SubtractEqual_FloatFloat ( float B, float* A )
{
	static UFunction* pSubtractEqual_FloatFloat = 0;
	UObject_execSubtractEqual_FloatFloat_Parms parms;

	if ( !pSubtractEqual_FloatFloat )
		pSubtractEqual_FloatFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.SubtractEqual_FloatFloat" );

	WORD iNative = pSubtractEqual_FloatFloat->iNative;
	pSubtractEqual_FloatFloat->FunctionFlags &= ~FUNC_Native;
	pSubtractEqual_FloatFloat->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pSubtractEqual_FloatFloat, &parms, NULL );

	pSubtractEqual_FloatFloat->iNative = iNative;
	pSubtractEqual_FloatFloat->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

float UObject::AddEqual_FloatFloat ( float B, float* A )
{
	static UFunction* pAddEqual_FloatFloat = 0;
	UObject_execAddEqual_FloatFloat_Parms parms;

	if ( !pAddEqual_FloatFloat )
		pAddEqual_FloatFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.AddEqual_FloatFloat" );

	WORD iNative = pAddEqual_FloatFloat->iNative;
	pAddEqual_FloatFloat->FunctionFlags &= ~FUNC_Native;
	pAddEqual_FloatFloat->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pAddEqual_FloatFloat, &parms, NULL );

	pAddEqual_FloatFloat->iNative = iNative;
	pAddEqual_FloatFloat->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

float UObject::DivideEqual_FloatFloat ( float B, float* A )
{
	static UFunction* pDivideEqual_FloatFloat = 0;
	UObject_execDivideEqual_FloatFloat_Parms parms;

	if ( !pDivideEqual_FloatFloat )
		pDivideEqual_FloatFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.DivideEqual_FloatFloat" );

	WORD iNative = pDivideEqual_FloatFloat->iNative;
	pDivideEqual_FloatFloat->FunctionFlags &= ~FUNC_Native;
	pDivideEqual_FloatFloat->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pDivideEqual_FloatFloat, &parms, NULL );

	pDivideEqual_FloatFloat->iNative = iNative;
	pDivideEqual_FloatFloat->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

float UObject::MultiplyEqual_FloatFloat ( float B, float* A )
{
	static UFunction* pMultiplyEqual_FloatFloat = 0;
	UObject_execMultiplyEqual_FloatFloat_Parms parms;

	if ( !pMultiplyEqual_FloatFloat )
		pMultiplyEqual_FloatFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.MultiplyEqual_FloatFloat" );

	WORD iNative = pMultiplyEqual_FloatFloat->iNative;
	pMultiplyEqual_FloatFloat->FunctionFlags &= ~FUNC_Native;
	pMultiplyEqual_FloatFloat->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pMultiplyEqual_FloatFloat, &parms, NULL );

	pMultiplyEqual_FloatFloat->iNative = iNative;
	pMultiplyEqual_FloatFloat->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

bool UObject::NotEqual_FloatFloat ( float A, float B )
{
	static UFunction* pNotEqual_FloatFloat = 0;
	UObject_execNotEqual_FloatFloat_Parms parms;

	if ( !pNotEqual_FloatFloat )
		pNotEqual_FloatFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.NotEqual_FloatFloat" );

	WORD iNative = pNotEqual_FloatFloat->iNative;
	pNotEqual_FloatFloat->FunctionFlags &= ~FUNC_Native;
	pNotEqual_FloatFloat->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pNotEqual_FloatFloat, &parms, NULL );

	pNotEqual_FloatFloat->iNative = iNative;
	pNotEqual_FloatFloat->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::ComplementEqual_FloatFloat ( float A, float B )
{
	static UFunction* pComplementEqual_FloatFloat = 0;
	UObject_execComplementEqual_FloatFloat_Parms parms;

	if ( !pComplementEqual_FloatFloat )
		pComplementEqual_FloatFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.ComplementEqual_FloatFloat" );

	WORD iNative = pComplementEqual_FloatFloat->iNative;
	pComplementEqual_FloatFloat->FunctionFlags &= ~FUNC_Native;
	pComplementEqual_FloatFloat->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pComplementEqual_FloatFloat, &parms, NULL );

	pComplementEqual_FloatFloat->iNative = iNative;
	pComplementEqual_FloatFloat->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::EqualEqual_FloatFloat ( float A, float B )
{
	static UFunction* pEqualEqual_FloatFloat = 0;
	UObject_execEqualEqual_FloatFloat_Parms parms;

	if ( !pEqualEqual_FloatFloat )
		pEqualEqual_FloatFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.EqualEqual_FloatFloat" );

	WORD iNative = pEqualEqual_FloatFloat->iNative;
	pEqualEqual_FloatFloat->FunctionFlags &= ~FUNC_Native;
	pEqualEqual_FloatFloat->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pEqualEqual_FloatFloat, &parms, NULL );

	pEqualEqual_FloatFloat->iNative = iNative;
	pEqualEqual_FloatFloat->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::GreaterEqual_FloatFloat ( float A, float B )
{
	static UFunction* pGreaterEqual_FloatFloat = 0;
	UObject_execGreaterEqual_FloatFloat_Parms parms;

	if ( !pGreaterEqual_FloatFloat )
		pGreaterEqual_FloatFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.GreaterEqual_FloatFloat" );

	WORD iNative = pGreaterEqual_FloatFloat->iNative;
	pGreaterEqual_FloatFloat->FunctionFlags &= ~FUNC_Native;
	pGreaterEqual_FloatFloat->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pGreaterEqual_FloatFloat, &parms, NULL );

	pGreaterEqual_FloatFloat->iNative = iNative;
	pGreaterEqual_FloatFloat->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::LessEqual_FloatFloat ( float A, float B )
{
	static UFunction* pLessEqual_FloatFloat = 0;
	UObject_execLessEqual_FloatFloat_Parms parms;

	if ( !pLessEqual_FloatFloat )
		pLessEqual_FloatFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.LessEqual_FloatFloat" );

	WORD iNative = pLessEqual_FloatFloat->iNative;
	pLessEqual_FloatFloat->FunctionFlags &= ~FUNC_Native;
	pLessEqual_FloatFloat->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pLessEqual_FloatFloat, &parms, NULL );

	pLessEqual_FloatFloat->iNative = iNative;
	pLessEqual_FloatFloat->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::Greater_FloatFloat ( float A, float B )
{
	static UFunction* pGreater_FloatFloat = 0;
	UObject_execGreater_FloatFloat_Parms parms;

	if ( !pGreater_FloatFloat )
		pGreater_FloatFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Greater_FloatFloat" );

	WORD iNative = pGreater_FloatFloat->iNative;
	pGreater_FloatFloat->FunctionFlags &= ~FUNC_Native;
	pGreater_FloatFloat->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pGreater_FloatFloat, &parms, NULL );

	pGreater_FloatFloat->iNative = iNative;
	pGreater_FloatFloat->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::Less_FloatFloat ( float A, float B )
{
	static UFunction* pLess_FloatFloat = 0;
	UObject_execLess_FloatFloat_Parms parms;

	if ( !pLess_FloatFloat )
		pLess_FloatFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Less_FloatFloat" );

	WORD iNative = pLess_FloatFloat->iNative;
	pLess_FloatFloat->FunctionFlags &= ~FUNC_Native;
	pLess_FloatFloat->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pLess_FloatFloat, &parms, NULL );

	pLess_FloatFloat->iNative = iNative;
	pLess_FloatFloat->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::Subtract_FloatFloat ( float A, float B )
{
	static UFunction* pSubtract_FloatFloat = 0;
	UObject_execSubtract_FloatFloat_Parms parms;

	if ( !pSubtract_FloatFloat )
		pSubtract_FloatFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Subtract_FloatFloat" );

	WORD iNative = pSubtract_FloatFloat->iNative;
	pSubtract_FloatFloat->FunctionFlags &= ~FUNC_Native;
	pSubtract_FloatFloat->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pSubtract_FloatFloat, &parms, NULL );

	pSubtract_FloatFloat->iNative = iNative;
	pSubtract_FloatFloat->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::Add_FloatFloat ( float A, float B )
{
	static UFunction* pAdd_FloatFloat = 0;
	UObject_execAdd_FloatFloat_Parms parms;

	if ( !pAdd_FloatFloat )
		pAdd_FloatFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Add_FloatFloat" );

	WORD iNative = pAdd_FloatFloat->iNative;
	pAdd_FloatFloat->FunctionFlags &= ~FUNC_Native;
	pAdd_FloatFloat->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pAdd_FloatFloat, &parms, NULL );

	pAdd_FloatFloat->iNative = iNative;
	pAdd_FloatFloat->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::Percent_FloatFloat ( float A, float B )
{
	static UFunction* pPercent_FloatFloat = 0;
	UObject_execPercent_FloatFloat_Parms parms;

	if ( !pPercent_FloatFloat )
		pPercent_FloatFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Percent_FloatFloat" );

	WORD iNative = pPercent_FloatFloat->iNative;
	pPercent_FloatFloat->FunctionFlags &= ~FUNC_Native;
	pPercent_FloatFloat->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pPercent_FloatFloat, &parms, NULL );

	pPercent_FloatFloat->iNative = iNative;
	pPercent_FloatFloat->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::Divide_FloatFloat ( float A, float B )
{
	static UFunction* pDivide_FloatFloat = 0;
	UObject_execDivide_FloatFloat_Parms parms;

	if ( !pDivide_FloatFloat )
		pDivide_FloatFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Divide_FloatFloat" );

	WORD iNative = pDivide_FloatFloat->iNative;
	pDivide_FloatFloat->FunctionFlags &= ~FUNC_Native;
	pDivide_FloatFloat->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pDivide_FloatFloat, &parms, NULL );

	pDivide_FloatFloat->iNative = iNative;
	pDivide_FloatFloat->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::Multiply_FloatFloat ( float A, float B )
{
	static UFunction* pMultiply_FloatFloat = 0;
	UObject_execMultiply_FloatFloat_Parms parms;

	if ( !pMultiply_FloatFloat )
		pMultiply_FloatFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Multiply_FloatFloat" );

	WORD iNative = pMultiply_FloatFloat->iNative;
	pMultiply_FloatFloat->FunctionFlags &= ~FUNC_Native;
	pMultiply_FloatFloat->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pMultiply_FloatFloat, &parms, NULL );

	pMultiply_FloatFloat->iNative = iNative;
	pMultiply_FloatFloat->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::MultiplyMultiply_FloatFloat ( float A, float B )
{
	static UFunction* pMultiplyMultiply_FloatFloat = 0;
	UObject_execMultiplyMultiply_FloatFloat_Parms parms;

	if ( !pMultiplyMultiply_FloatFloat )
		pMultiplyMultiply_FloatFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.MultiplyMultiply_FloatFloat" );

	WORD iNative = pMultiplyMultiply_FloatFloat->iNative;
	pMultiplyMultiply_FloatFloat->FunctionFlags &= ~FUNC_Native;
	pMultiplyMultiply_FloatFloat->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pMultiplyMultiply_FloatFloat, &parms, NULL );

	pMultiplyMultiply_FloatFloat->iNative = iNative;
	pMultiplyMultiply_FloatFloat->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

float UObject::Subtract_PreFloat ( float A )
{
	static UFunction* pSubtract_PreFloat = 0;
	UObject_execSubtract_PreFloat_Parms parms;

	if ( !pSubtract_PreFloat )
		pSubtract_PreFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Subtract_PreFloat" );

	WORD iNative = pSubtract_PreFloat->iNative;
	pSubtract_PreFloat->FunctionFlags &= ~FUNC_Native;
	pSubtract_PreFloat->iNative = 0;

	parms.A = A;
	this->ProcessEvent ( pSubtract_PreFloat, &parms, NULL );

	pSubtract_PreFloat->iNative = iNative;
	pSubtract_PreFloat->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

int UObject::Clamp ( int V, int A, int B )
{
	static UFunction* pClamp = 0;
	UObject_execClamp_Parms parms;

	if ( !pClamp )
		pClamp = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Clamp" );

	WORD iNative = pClamp->iNative;
	pClamp->FunctionFlags &= ~FUNC_Native;
	pClamp->iNative = 0;

	parms.V = V;
	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pClamp, &parms, NULL );

	pClamp->iNative = iNative;
	pClamp->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

int UObject::Max ( int A, int B )
{
	static UFunction* pMax = 0;
	UObject_execMax_Parms parms;

	if ( !pMax )
		pMax = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Max" );

	WORD iNative = pMax->iNative;
	pMax->FunctionFlags &= ~FUNC_Native;
	pMax->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pMax, &parms, NULL );

	pMax->iNative = iNative;
	pMax->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

int UObject::Min ( int A, int B )
{
	static UFunction* pMin = 0;
	UObject_execMin_Parms parms;

	if ( !pMin )
		pMin = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Min" );

	WORD iNative = pMin->iNative;
	pMin->FunctionFlags &= ~FUNC_Native;
	pMin->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pMin, &parms, NULL );

	pMin->iNative = iNative;
	pMin->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

void UObject::SRand ( int Seed )
{
	static UFunction* pSRand = 0;
	UObject_execSRand_Parms parms;

	if ( !pSRand )
		pSRand = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.SRand" );

	parms.Seed = Seed;
	this->ProcessEvent ( pSRand, &parms, NULL );

}

int UObject::Rand ( int Max )
{
	static UFunction* pRand = 0;
	UObject_execRand_Parms parms;

	if ( !pRand )
		pRand = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Rand" );

	WORD iNative = pRand->iNative;
	pRand->FunctionFlags &= ~FUNC_Native;
	pRand->iNative = 0;

	parms.Max = Max;
	this->ProcessEvent ( pRand, &parms, NULL );

	pRand->iNative = iNative;
	pRand->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

int UObject::SubtractSubtract_Int ( int* A )
{
	static UFunction* pSubtractSubtract_Int = 0;
	UObject_execSubtractSubtract_Int_Parms parms;

	if ( !pSubtractSubtract_Int )
		pSubtractSubtract_Int = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.SubtractSubtract_Int" );

	WORD iNative = pSubtractSubtract_Int->iNative;
	pSubtractSubtract_Int->FunctionFlags &= ~FUNC_Native;
	pSubtractSubtract_Int->iNative = 0;

	parms.A = *A;
	this->ProcessEvent ( pSubtractSubtract_Int, &parms, NULL );

	pSubtractSubtract_Int->iNative = iNative;
	pSubtractSubtract_Int->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

int UObject::AddAdd_Int ( int* A )
{
	static UFunction* pAddAdd_Int = 0;
	UObject_execAddAdd_Int_Parms parms;

	if ( !pAddAdd_Int )
		pAddAdd_Int = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.AddAdd_Int" );

	WORD iNative = pAddAdd_Int->iNative;
	pAddAdd_Int->FunctionFlags &= ~FUNC_Native;
	pAddAdd_Int->iNative = 0;

	parms.A = *A;
	this->ProcessEvent ( pAddAdd_Int, &parms, NULL );

	pAddAdd_Int->iNative = iNative;
	pAddAdd_Int->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

int UObject::SubtractSubtract_PreInt ( int* A )
{
	static UFunction* pSubtractSubtract_PreInt = 0;
	UObject_execSubtractSubtract_PreInt_Parms parms;

	if ( !pSubtractSubtract_PreInt )
		pSubtractSubtract_PreInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.SubtractSubtract_PreInt" );

	WORD iNative = pSubtractSubtract_PreInt->iNative;
	pSubtractSubtract_PreInt->FunctionFlags &= ~FUNC_Native;
	pSubtractSubtract_PreInt->iNative = 0;

	parms.A = *A;
	this->ProcessEvent ( pSubtractSubtract_PreInt, &parms, NULL );

	pSubtractSubtract_PreInt->iNative = iNative;
	pSubtractSubtract_PreInt->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

int UObject::AddAdd_PreInt ( int* A )
{
	static UFunction* pAddAdd_PreInt = 0;
	UObject_execAddAdd_PreInt_Parms parms;

	if ( !pAddAdd_PreInt )
		pAddAdd_PreInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.AddAdd_PreInt" );

	WORD iNative = pAddAdd_PreInt->iNative;
	pAddAdd_PreInt->FunctionFlags &= ~FUNC_Native;
	pAddAdd_PreInt->iNative = 0;

	parms.A = *A;
	this->ProcessEvent ( pAddAdd_PreInt, &parms, NULL );

	pAddAdd_PreInt->iNative = iNative;
	pAddAdd_PreInt->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

int UObject::SubtractEqual_IntInt ( int B, int* A )
{
	static UFunction* pSubtractEqual_IntInt = 0;
	UObject_execSubtractEqual_IntInt_Parms parms;

	if ( !pSubtractEqual_IntInt )
		pSubtractEqual_IntInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.SubtractEqual_IntInt" );

	WORD iNative = pSubtractEqual_IntInt->iNative;
	pSubtractEqual_IntInt->FunctionFlags &= ~FUNC_Native;
	pSubtractEqual_IntInt->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pSubtractEqual_IntInt, &parms, NULL );

	pSubtractEqual_IntInt->iNative = iNative;
	pSubtractEqual_IntInt->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

int UObject::AddEqual_IntInt ( int B, int* A )
{
	static UFunction* pAddEqual_IntInt = 0;
	UObject_execAddEqual_IntInt_Parms parms;

	if ( !pAddEqual_IntInt )
		pAddEqual_IntInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.AddEqual_IntInt" );

	WORD iNative = pAddEqual_IntInt->iNative;
	pAddEqual_IntInt->FunctionFlags &= ~FUNC_Native;
	pAddEqual_IntInt->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pAddEqual_IntInt, &parms, NULL );

	pAddEqual_IntInt->iNative = iNative;
	pAddEqual_IntInt->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

int UObject::DivideEqual_IntFloat ( float B, int* A )
{
	static UFunction* pDivideEqual_IntFloat = 0;
	UObject_execDivideEqual_IntFloat_Parms parms;

	if ( !pDivideEqual_IntFloat )
		pDivideEqual_IntFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.DivideEqual_IntFloat" );

	WORD iNative = pDivideEqual_IntFloat->iNative;
	pDivideEqual_IntFloat->FunctionFlags &= ~FUNC_Native;
	pDivideEqual_IntFloat->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pDivideEqual_IntFloat, &parms, NULL );

	pDivideEqual_IntFloat->iNative = iNative;
	pDivideEqual_IntFloat->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

int UObject::MultiplyEqual_IntFloat ( float B, int* A )
{
	static UFunction* pMultiplyEqual_IntFloat = 0;
	UObject_execMultiplyEqual_IntFloat_Parms parms;

	if ( !pMultiplyEqual_IntFloat )
		pMultiplyEqual_IntFloat = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.MultiplyEqual_IntFloat" );

	WORD iNative = pMultiplyEqual_IntFloat->iNative;
	pMultiplyEqual_IntFloat->FunctionFlags &= ~FUNC_Native;
	pMultiplyEqual_IntFloat->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pMultiplyEqual_IntFloat, &parms, NULL );

	pMultiplyEqual_IntFloat->iNative = iNative;
	pMultiplyEqual_IntFloat->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

int UObject::Or_IntInt ( int A, int B )
{
	static UFunction* pOr_IntInt = 0;
	UObject_execOr_IntInt_Parms parms;

	if ( !pOr_IntInt )
		pOr_IntInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Or_IntInt" );

	WORD iNative = pOr_IntInt->iNative;
	pOr_IntInt->FunctionFlags &= ~FUNC_Native;
	pOr_IntInt->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pOr_IntInt, &parms, NULL );

	pOr_IntInt->iNative = iNative;
	pOr_IntInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

int UObject::Xor_IntInt ( int A, int B )
{
	static UFunction* pXor_IntInt = 0;
	UObject_execXor_IntInt_Parms parms;

	if ( !pXor_IntInt )
		pXor_IntInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Xor_IntInt" );

	WORD iNative = pXor_IntInt->iNative;
	pXor_IntInt->FunctionFlags &= ~FUNC_Native;
	pXor_IntInt->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pXor_IntInt, &parms, NULL );

	pXor_IntInt->iNative = iNative;
	pXor_IntInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

int UObject::And_IntInt ( int A, int B )
{
	static UFunction* pAnd_IntInt = 0;
	UObject_execAnd_IntInt_Parms parms;

	if ( !pAnd_IntInt )
		pAnd_IntInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.And_IntInt" );

	WORD iNative = pAnd_IntInt->iNative;
	pAnd_IntInt->FunctionFlags &= ~FUNC_Native;
	pAnd_IntInt->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pAnd_IntInt, &parms, NULL );

	pAnd_IntInt->iNative = iNative;
	pAnd_IntInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::NotEqual_IntInt ( int A, int B )
{
	static UFunction* pNotEqual_IntInt = 0;
	UObject_execNotEqual_IntInt_Parms parms;

	if ( !pNotEqual_IntInt )
		pNotEqual_IntInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.NotEqual_IntInt" );

	WORD iNative = pNotEqual_IntInt->iNative;
	pNotEqual_IntInt->FunctionFlags &= ~FUNC_Native;
	pNotEqual_IntInt->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pNotEqual_IntInt, &parms, NULL );

	pNotEqual_IntInt->iNative = iNative;
	pNotEqual_IntInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::EqualEqual_IntInt ( int A, int B )
{
	static UFunction* pEqualEqual_IntInt = 0;
	UObject_execEqualEqual_IntInt_Parms parms;

	if ( !pEqualEqual_IntInt )
		pEqualEqual_IntInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.EqualEqual_IntInt" );

	WORD iNative = pEqualEqual_IntInt->iNative;
	pEqualEqual_IntInt->FunctionFlags &= ~FUNC_Native;
	pEqualEqual_IntInt->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pEqualEqual_IntInt, &parms, NULL );

	pEqualEqual_IntInt->iNative = iNative;
	pEqualEqual_IntInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::GreaterEqual_IntInt ( int A, int B )
{
	static UFunction* pGreaterEqual_IntInt = 0;
	UObject_execGreaterEqual_IntInt_Parms parms;

	if ( !pGreaterEqual_IntInt )
		pGreaterEqual_IntInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.GreaterEqual_IntInt" );

	WORD iNative = pGreaterEqual_IntInt->iNative;
	pGreaterEqual_IntInt->FunctionFlags &= ~FUNC_Native;
	pGreaterEqual_IntInt->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pGreaterEqual_IntInt, &parms, NULL );

	pGreaterEqual_IntInt->iNative = iNative;
	pGreaterEqual_IntInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::LessEqual_IntInt ( int A, int B )
{
	static UFunction* pLessEqual_IntInt = 0;
	UObject_execLessEqual_IntInt_Parms parms;

	if ( !pLessEqual_IntInt )
		pLessEqual_IntInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.LessEqual_IntInt" );

	WORD iNative = pLessEqual_IntInt->iNative;
	pLessEqual_IntInt->FunctionFlags &= ~FUNC_Native;
	pLessEqual_IntInt->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pLessEqual_IntInt, &parms, NULL );

	pLessEqual_IntInt->iNative = iNative;
	pLessEqual_IntInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::Greater_IntInt ( int A, int B )
{
	static UFunction* pGreater_IntInt = 0;
	UObject_execGreater_IntInt_Parms parms;

	if ( !pGreater_IntInt )
		pGreater_IntInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Greater_IntInt" );

	WORD iNative = pGreater_IntInt->iNative;
	pGreater_IntInt->FunctionFlags &= ~FUNC_Native;
	pGreater_IntInt->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pGreater_IntInt, &parms, NULL );

	pGreater_IntInt->iNative = iNative;
	pGreater_IntInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::Less_IntInt ( int A, int B )
{
	static UFunction* pLess_IntInt = 0;
	UObject_execLess_IntInt_Parms parms;

	if ( !pLess_IntInt )
		pLess_IntInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Less_IntInt" );

	WORD iNative = pLess_IntInt->iNative;
	pLess_IntInt->FunctionFlags &= ~FUNC_Native;
	pLess_IntInt->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pLess_IntInt, &parms, NULL );

	pLess_IntInt->iNative = iNative;
	pLess_IntInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

int UObject::GreaterGreaterGreater_IntInt ( int A, int B )
{
	static UFunction* pGreaterGreaterGreater_IntInt = 0;
	UObject_execGreaterGreaterGreater_IntInt_Parms parms;

	if ( !pGreaterGreaterGreater_IntInt )
		pGreaterGreaterGreater_IntInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.GreaterGreaterGreater_IntInt" );

	WORD iNative = pGreaterGreaterGreater_IntInt->iNative;
	pGreaterGreaterGreater_IntInt->FunctionFlags &= ~FUNC_Native;
	pGreaterGreaterGreater_IntInt->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pGreaterGreaterGreater_IntInt, &parms, NULL );

	pGreaterGreaterGreater_IntInt->iNative = iNative;
	pGreaterGreaterGreater_IntInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

int UObject::GreaterGreater_IntInt ( int A, int B )
{
	static UFunction* pGreaterGreater_IntInt = 0;
	UObject_execGreaterGreater_IntInt_Parms parms;

	if ( !pGreaterGreater_IntInt )
		pGreaterGreater_IntInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.GreaterGreater_IntInt" );

	WORD iNative = pGreaterGreater_IntInt->iNative;
	pGreaterGreater_IntInt->FunctionFlags &= ~FUNC_Native;
	pGreaterGreater_IntInt->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pGreaterGreater_IntInt, &parms, NULL );

	pGreaterGreater_IntInt->iNative = iNative;
	pGreaterGreater_IntInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

int UObject::LessLess_IntInt ( int A, int B )
{
	static UFunction* pLessLess_IntInt = 0;
	UObject_execLessLess_IntInt_Parms parms;

	if ( !pLessLess_IntInt )
		pLessLess_IntInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.LessLess_IntInt" );

	WORD iNative = pLessLess_IntInt->iNative;
	pLessLess_IntInt->FunctionFlags &= ~FUNC_Native;
	pLessLess_IntInt->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pLessLess_IntInt, &parms, NULL );

	pLessLess_IntInt->iNative = iNative;
	pLessLess_IntInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

int UObject::Subtract_IntInt ( int A, int B )
{
	static UFunction* pSubtract_IntInt = 0;
	UObject_execSubtract_IntInt_Parms parms;

	if ( !pSubtract_IntInt )
		pSubtract_IntInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Subtract_IntInt" );

	WORD iNative = pSubtract_IntInt->iNative;
	pSubtract_IntInt->FunctionFlags &= ~FUNC_Native;
	pSubtract_IntInt->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pSubtract_IntInt, &parms, NULL );

	pSubtract_IntInt->iNative = iNative;
	pSubtract_IntInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

int UObject::Add_IntInt ( int A, int B )
{
	static UFunction* pAdd_IntInt = 0;
	UObject_execAdd_IntInt_Parms parms;

	if ( !pAdd_IntInt )
		pAdd_IntInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Add_IntInt" );

	WORD iNative = pAdd_IntInt->iNative;
	pAdd_IntInt->FunctionFlags &= ~FUNC_Native;
	pAdd_IntInt->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pAdd_IntInt, &parms, NULL );

	pAdd_IntInt->iNative = iNative;
	pAdd_IntInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

int UObject::Divide_IntInt ( int A, int B )
{
	static UFunction* pDivide_IntInt = 0;
	UObject_execDivide_IntInt_Parms parms;

	if ( !pDivide_IntInt )
		pDivide_IntInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Divide_IntInt" );

	WORD iNative = pDivide_IntInt->iNative;
	pDivide_IntInt->FunctionFlags &= ~FUNC_Native;
	pDivide_IntInt->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pDivide_IntInt, &parms, NULL );

	pDivide_IntInt->iNative = iNative;
	pDivide_IntInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

int UObject::Multiply_IntInt ( int A, int B )
{
	static UFunction* pMultiply_IntInt = 0;
	UObject_execMultiply_IntInt_Parms parms;

	if ( !pMultiply_IntInt )
		pMultiply_IntInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Multiply_IntInt" );

	WORD iNative = pMultiply_IntInt->iNative;
	pMultiply_IntInt->FunctionFlags &= ~FUNC_Native;
	pMultiply_IntInt->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pMultiply_IntInt, &parms, NULL );

	pMultiply_IntInt->iNative = iNative;
	pMultiply_IntInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

int UObject::Subtract_PreInt ( int A )
{
	static UFunction* pSubtract_PreInt = 0;
	UObject_execSubtract_PreInt_Parms parms;

	if ( !pSubtract_PreInt )
		pSubtract_PreInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Subtract_PreInt" );

	WORD iNative = pSubtract_PreInt->iNative;
	pSubtract_PreInt->FunctionFlags &= ~FUNC_Native;
	pSubtract_PreInt->iNative = 0;

	parms.A = A;
	this->ProcessEvent ( pSubtract_PreInt, &parms, NULL );

	pSubtract_PreInt->iNative = iNative;
	pSubtract_PreInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

int UObject::Complement_PreInt ( int A )
{
	static UFunction* pComplement_PreInt = 0;
	UObject_execComplement_PreInt_Parms parms;

	if ( !pComplement_PreInt )
		pComplement_PreInt = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Complement_PreInt" );

	WORD iNative = pComplement_PreInt->iNative;
	pComplement_PreInt->FunctionFlags &= ~FUNC_Native;
	pComplement_PreInt->iNative = 0;

	parms.A = A;
	this->ProcessEvent ( pComplement_PreInt, &parms, NULL );

	pComplement_PreInt->iNative = iNative;
	pComplement_PreInt->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

unsigned char UObject::SubtractSubtract_Byte ( unsigned char* A )
{
	static UFunction* pSubtractSubtract_Byte = 0;
	UObject_execSubtractSubtract_Byte_Parms parms;

	if ( !pSubtractSubtract_Byte )
		pSubtractSubtract_Byte = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.SubtractSubtract_Byte" );

	WORD iNative = pSubtractSubtract_Byte->iNative;
	pSubtractSubtract_Byte->FunctionFlags &= ~FUNC_Native;
	pSubtractSubtract_Byte->iNative = 0;

	parms.A = *A;
	this->ProcessEvent ( pSubtractSubtract_Byte, &parms, NULL );

	pSubtractSubtract_Byte->iNative = iNative;
	pSubtractSubtract_Byte->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

unsigned char UObject::AddAdd_Byte ( unsigned char* A )
{
	static UFunction* pAddAdd_Byte = 0;
	UObject_execAddAdd_Byte_Parms parms;

	if ( !pAddAdd_Byte )
		pAddAdd_Byte = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.AddAdd_Byte" );

	WORD iNative = pAddAdd_Byte->iNative;
	pAddAdd_Byte->FunctionFlags &= ~FUNC_Native;
	pAddAdd_Byte->iNative = 0;

	parms.A = *A;
	this->ProcessEvent ( pAddAdd_Byte, &parms, NULL );

	pAddAdd_Byte->iNative = iNative;
	pAddAdd_Byte->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

unsigned char UObject::SubtractSubtract_PreByte ( unsigned char* A )
{
	static UFunction* pSubtractSubtract_PreByte = 0;
	UObject_execSubtractSubtract_PreByte_Parms parms;

	if ( !pSubtractSubtract_PreByte )
		pSubtractSubtract_PreByte = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.SubtractSubtract_PreByte" );

	WORD iNative = pSubtractSubtract_PreByte->iNative;
	pSubtractSubtract_PreByte->FunctionFlags &= ~FUNC_Native;
	pSubtractSubtract_PreByte->iNative = 0;

	parms.A = *A;
	this->ProcessEvent ( pSubtractSubtract_PreByte, &parms, NULL );

	pSubtractSubtract_PreByte->iNative = iNative;
	pSubtractSubtract_PreByte->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

unsigned char UObject::AddAdd_PreByte ( unsigned char* A )
{
	static UFunction* pAddAdd_PreByte = 0;
	UObject_execAddAdd_PreByte_Parms parms;

	if ( !pAddAdd_PreByte )
		pAddAdd_PreByte = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.AddAdd_PreByte" );

	WORD iNative = pAddAdd_PreByte->iNative;
	pAddAdd_PreByte->FunctionFlags &= ~FUNC_Native;
	pAddAdd_PreByte->iNative = 0;

	parms.A = *A;
	this->ProcessEvent ( pAddAdd_PreByte, &parms, NULL );

	pAddAdd_PreByte->iNative = iNative;
	pAddAdd_PreByte->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

unsigned char UObject::SubtractEqual_ByteByte ( unsigned char B, unsigned char* A )
{
	static UFunction* pSubtractEqual_ByteByte = 0;
	UObject_execSubtractEqual_ByteByte_Parms parms;

	if ( !pSubtractEqual_ByteByte )
		pSubtractEqual_ByteByte = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.SubtractEqual_ByteByte" );

	WORD iNative = pSubtractEqual_ByteByte->iNative;
	pSubtractEqual_ByteByte->FunctionFlags &= ~FUNC_Native;
	pSubtractEqual_ByteByte->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pSubtractEqual_ByteByte, &parms, NULL );

	pSubtractEqual_ByteByte->iNative = iNative;
	pSubtractEqual_ByteByte->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

unsigned char UObject::AddEqual_ByteByte ( unsigned char B, unsigned char* A )
{
	static UFunction* pAddEqual_ByteByte = 0;
	UObject_execAddEqual_ByteByte_Parms parms;

	if ( !pAddEqual_ByteByte )
		pAddEqual_ByteByte = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.AddEqual_ByteByte" );

	WORD iNative = pAddEqual_ByteByte->iNative;
	pAddEqual_ByteByte->FunctionFlags &= ~FUNC_Native;
	pAddEqual_ByteByte->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pAddEqual_ByteByte, &parms, NULL );

	pAddEqual_ByteByte->iNative = iNative;
	pAddEqual_ByteByte->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

unsigned char UObject::DivideEqual_ByteByte ( unsigned char B, unsigned char* A )
{
	static UFunction* pDivideEqual_ByteByte = 0;
	UObject_execDivideEqual_ByteByte_Parms parms;

	if ( !pDivideEqual_ByteByte )
		pDivideEqual_ByteByte = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.DivideEqual_ByteByte" );

	WORD iNative = pDivideEqual_ByteByte->iNative;
	pDivideEqual_ByteByte->FunctionFlags &= ~FUNC_Native;
	pDivideEqual_ByteByte->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pDivideEqual_ByteByte, &parms, NULL );

	pDivideEqual_ByteByte->iNative = iNative;
	pDivideEqual_ByteByte->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

unsigned char UObject::MultiplyEqual_ByteByte ( unsigned char B, unsigned char* A )
{
	static UFunction* pMultiplyEqual_ByteByte = 0;
	UObject_execMultiplyEqual_ByteByte_Parms parms;

	if ( !pMultiplyEqual_ByteByte )
		pMultiplyEqual_ByteByte = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.MultiplyEqual_ByteByte" );

	WORD iNative = pMultiplyEqual_ByteByte->iNative;
	pMultiplyEqual_ByteByte->FunctionFlags &= ~FUNC_Native;
	pMultiplyEqual_ByteByte->iNative = 0;

	parms.B = B;
	this->ProcessEvent ( pMultiplyEqual_ByteByte, &parms, NULL );

	pMultiplyEqual_ByteByte->iNative = iNative;
	pMultiplyEqual_ByteByte->FunctionFlags |= FUNC_Native;
	*A = parms.A;
	return parms.ReturnValue;
}

bool UObject::OrOr_BoolBool ( bool A, bool B )
{
	static UFunction* pOrOr_BoolBool = 0;
	UObject_execOrOr_BoolBool_Parms parms;

	if ( !pOrOr_BoolBool )
		pOrOr_BoolBool = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.OrOr_BoolBool" );

	WORD iNative = pOrOr_BoolBool->iNative;
	pOrOr_BoolBool->FunctionFlags &= ~FUNC_Native;
	pOrOr_BoolBool->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pOrOr_BoolBool, &parms, NULL );

	pOrOr_BoolBool->iNative = iNative;
	pOrOr_BoolBool->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::XorXor_BoolBool ( bool A, bool B )
{
	static UFunction* pXorXor_BoolBool = 0;
	UObject_execXorXor_BoolBool_Parms parms;

	if ( !pXorXor_BoolBool )
		pXorXor_BoolBool = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.XorXor_BoolBool" );

	WORD iNative = pXorXor_BoolBool->iNative;
	pXorXor_BoolBool->FunctionFlags &= ~FUNC_Native;
	pXorXor_BoolBool->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pXorXor_BoolBool, &parms, NULL );

	pXorXor_BoolBool->iNative = iNative;
	pXorXor_BoolBool->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::AndAnd_BoolBool ( bool A, bool B )
{
	static UFunction* pAndAnd_BoolBool = 0;
	UObject_execAndAnd_BoolBool_Parms parms;

	if ( !pAndAnd_BoolBool )
		pAndAnd_BoolBool = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.AndAnd_BoolBool" );

	WORD iNative = pAndAnd_BoolBool->iNative;
	pAndAnd_BoolBool->FunctionFlags &= ~FUNC_Native;
	pAndAnd_BoolBool->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pAndAnd_BoolBool, &parms, NULL );

	pAndAnd_BoolBool->iNative = iNative;
	pAndAnd_BoolBool->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::NotEqual_BoolBool ( bool A, bool B )
{
	static UFunction* pNotEqual_BoolBool = 0;
	UObject_execNotEqual_BoolBool_Parms parms;

	if ( !pNotEqual_BoolBool )
		pNotEqual_BoolBool = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.NotEqual_BoolBool" );

	WORD iNative = pNotEqual_BoolBool->iNative;
	pNotEqual_BoolBool->FunctionFlags &= ~FUNC_Native;
	pNotEqual_BoolBool->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pNotEqual_BoolBool, &parms, NULL );

	pNotEqual_BoolBool->iNative = iNative;
	pNotEqual_BoolBool->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::EqualEqual_BoolBool ( bool A, bool B )
{
	static UFunction* pEqualEqual_BoolBool = 0;
	UObject_execEqualEqual_BoolBool_Parms parms;

	if ( !pEqualEqual_BoolBool )
		pEqualEqual_BoolBool = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.EqualEqual_BoolBool" );

	WORD iNative = pEqualEqual_BoolBool->iNative;
	pEqualEqual_BoolBool->FunctionFlags &= ~FUNC_Native;
	pEqualEqual_BoolBool->iNative = 0;

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pEqualEqual_BoolBool, &parms, NULL );

	pEqualEqual_BoolBool->iNative = iNative;
	pEqualEqual_BoolBool->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

bool UObject::Not_PreBool ( bool A )
{
	static UFunction* pNot_PreBool = 0;
	UObject_execNot_PreBool_Parms parms;

	if ( !pNot_PreBool )
		pNot_PreBool = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.Not_PreBool" );

	WORD iNative = pNot_PreBool->iNative;
	pNot_PreBool->FunctionFlags &= ~FUNC_Native;
	pNot_PreBool->iNative = 0;

	parms.A = A;
	this->ProcessEvent ( pNot_PreBool, &parms, NULL );

	pNot_PreBool->iNative = iNative;
	pNot_PreBool->FunctionFlags |= FUNC_Native;
	return parms.ReturnValue;
}

void UObject::BtrTimeToBtrDouble ( struct FBtrTime* A, struct FBtrDouble* B )
{
	static UFunction* pBtrTimeToBtrDouble = 0;
	UObject_execBtrTimeToBtrDouble_Parms parms;

	if ( !pBtrTimeToBtrDouble )
		pBtrTimeToBtrDouble = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.BtrTimeToBtrDouble" );

	parms.A = *A;
	parms.B = *B;
	this->ProcessEvent ( pBtrTimeToBtrDouble, &parms, NULL );

	*A = parms.A;
	*B = parms.B;
}

bool UObject::BtrDoubleLessEqual ( struct FBtrDouble* A, struct FBtrDouble* B )
{
	static UFunction* pBtrDoubleLessEqual = 0;
	UObject_execBtrDoubleLessEqual_Parms parms;

	if ( !pBtrDoubleLessEqual )
		pBtrDoubleLessEqual = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.BtrDoubleLessEqual" );

	parms.A = *A;
	parms.B = *B;
	this->ProcessEvent ( pBtrDoubleLessEqual, &parms, NULL );

	*A = parms.A;
	*B = parms.B;
	return parms.ReturnValue;
}

void UObject::BtrDoubleToBtrTime ( struct FBtrDouble* A, struct FBtrTime* B )
{
	static UFunction* pBtrDoubleToBtrTime = 0;
	UObject_execBtrDoubleToBtrTime_Parms parms;

	if ( !pBtrDoubleToBtrTime )
		pBtrDoubleToBtrTime = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.BtrDoubleToBtrTime" );

	parms.A = *A;
	parms.B = *B;
	this->ProcessEvent ( pBtrDoubleToBtrTime, &parms, NULL );

	*A = parms.A;
	*B = parms.B;
}

void UObject::GetLocalTimeToBtrTime ( struct FBtrTime* A )
{
	static UFunction* pGetLocalTimeToBtrTime = 0;
	UObject_execGetLocalTimeToBtrTime_Parms parms;

	if ( !pGetLocalTimeToBtrTime )
		pGetLocalTimeToBtrTime = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.GetLocalTimeToBtrTime" );

	parms.A = *A;
	this->ProcessEvent ( pGetLocalTimeToBtrTime, &parms, NULL );

	*A = parms.A;
}

void UObject::GetLocalTimeToBtrDouble ( struct FBtrDouble* A )
{
	static UFunction* pGetLocalTimeToBtrDouble = 0;
	UObject_execGetLocalTimeToBtrDouble_Parms parms;

	if ( !pGetLocalTimeToBtrDouble )
		pGetLocalTimeToBtrDouble = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.GetLocalTimeToBtrDouble" );

	parms.A = *A;
	this->ProcessEvent ( pGetLocalTimeToBtrDouble, &parms, NULL );

	*A = parms.A;
}

struct FBtrDouble UObject::BtrDoublePlus ( struct FBtrDouble A, struct FBtrDouble B )
{
	static UFunction* pBtrDoublePlus = 0;
	UObject_execBtrDoublePlus_Parms parms;

	if ( !pBtrDoublePlus )
		pBtrDoublePlus = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.BtrDoublePlus" );

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pBtrDoublePlus, &parms, NULL );

	return parms.ReturnValue;
}

struct FBtrDouble UObject::BtrDoubleMinus ( struct FBtrDouble A, struct FBtrDouble B )
{
	static UFunction* pBtrDoubleMinus = 0;
	UObject_execBtrDoubleMinus_Parms parms;

	if ( !pBtrDoubleMinus )
		pBtrDoubleMinus = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.BtrDoubleMinus" );

	parms.A = A;
	parms.B = B;
	this->ProcessEvent ( pBtrDoubleMinus, &parms, NULL );

	return parms.ReturnValue;
}

struct FBtrTime UObject::EmptyBtrTime (  )
{
	static UFunction* pEmptyBtrTime = 0;
	UObject_execEmptyBtrTime_Parms parms;

	if ( !pEmptyBtrTime )
		pEmptyBtrTime = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.EmptyBtrTime" );

	this->ProcessEvent ( pEmptyBtrTime, &parms, NULL );

	return parms.ReturnValue;
}

struct FBtrDouble UObject::EmptyBtrDouble (  )
{
	static UFunction* pEmptyBtrDouble = 0;
	UObject_execEmptyBtrDouble_Parms parms;

	if ( !pEmptyBtrDouble )
		pEmptyBtrDouble = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.EmptyBtrDouble" );

	this->ProcessEvent ( pEmptyBtrDouble, &parms, NULL );

	return parms.ReturnValue;
}

struct FBtrTime UObject::BtrTimeSubstract ( struct FBtrTime leftT, struct FBtrTime rightT )
{
	static UFunction* pBtrTimeSubstract = 0;
	UObject_execBtrTimeSubstract_Parms parms;

	if ( !pBtrTimeSubstract )
		pBtrTimeSubstract = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.BtrTimeSubstract" );

	parms.leftT = leftT;
	parms.rightT = rightT;
	this->ProcessEvent ( pBtrTimeSubstract, &parms, NULL );

	return parms.ReturnValue;
}

struct FBtrTime UObject::BtrTimeToBtrDayTime ( struct FBtrTime it )
{
	static UFunction* pBtrTimeToBtrDayTime = 0;
	UObject_execBtrTimeToBtrDayTime_Parms parms;

	if ( !pBtrTimeToBtrDayTime )
		pBtrTimeToBtrDayTime = ( UFunction* )UFunction::StaticFindObject ( UFunction::StaticClass(), NULL, L"Core.Object.BtrTimeToBtrDayTime" );

	parms.it = it;
	this->ProcessEvent ( pBtrTimeToBtrDayTime, &parms, NULL );

	return parms.ReturnValue;
}

